// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "DataPrimitives.hxx"

// AngleUnitEnumType
// 

AngleUnitEnumType::
AngleUnitEnumType (value v)
: ::xml_schema::nmtoken (_xsd_AngleUnitEnumType_literals_[v])
{
}

AngleUnitEnumType::
AngleUnitEnumType (const char* v)
: ::xml_schema::nmtoken (v)
{
}

AngleUnitEnumType::
AngleUnitEnumType (const ::std::string& v)
: ::xml_schema::nmtoken (v)
{
}

AngleUnitEnumType::
AngleUnitEnumType (const ::xml_schema::nmtoken& v)
: ::xml_schema::nmtoken (v)
{
}

AngleUnitEnumType::
AngleUnitEnumType (const AngleUnitEnumType& v,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::nmtoken (v, f, c)
{
}

AngleUnitEnumType& AngleUnitEnumType::
operator= (value v)
{
  static_cast< ::xml_schema::nmtoken& > (*this) = 
  ::xml_schema::nmtoken (_xsd_AngleUnitEnumType_literals_[v]);

  return *this;
}


// DataThingType
// 

const DataThingType::Name_optional& DataThingType::
Name () const
{
  return this->Name_;
}

DataThingType::Name_optional& DataThingType::
Name ()
{
  return this->Name_;
}

void DataThingType::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void DataThingType::
Name (const Name_optional& x)
{
  this->Name_ = x;
}

void DataThingType::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}


// ForceUnitEnumType
// 

ForceUnitEnumType::
ForceUnitEnumType (value v)
: ::xml_schema::nmtoken (_xsd_ForceUnitEnumType_literals_[v])
{
}

ForceUnitEnumType::
ForceUnitEnumType (const char* v)
: ::xml_schema::nmtoken (v)
{
}

ForceUnitEnumType::
ForceUnitEnumType (const ::std::string& v)
: ::xml_schema::nmtoken (v)
{
}

ForceUnitEnumType::
ForceUnitEnumType (const ::xml_schema::nmtoken& v)
: ::xml_schema::nmtoken (v)
{
}

ForceUnitEnumType::
ForceUnitEnumType (const ForceUnitEnumType& v,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::nmtoken (v, f, c)
{
}

ForceUnitEnumType& ForceUnitEnumType::
operator= (value v)
{
  static_cast< ::xml_schema::nmtoken& > (*this) = 
  ::xml_schema::nmtoken (_xsd_ForceUnitEnumType_literals_[v]);

  return *this;
}


// FractionType
// 


// LengthUnitEnumType
// 

LengthUnitEnumType::
LengthUnitEnumType (value v)
: ::xml_schema::nmtoken (_xsd_LengthUnitEnumType_literals_[v])
{
}

LengthUnitEnumType::
LengthUnitEnumType (const char* v)
: ::xml_schema::nmtoken (v)
{
}

LengthUnitEnumType::
LengthUnitEnumType (const ::std::string& v)
: ::xml_schema::nmtoken (v)
{
}

LengthUnitEnumType::
LengthUnitEnumType (const ::xml_schema::nmtoken& v)
: ::xml_schema::nmtoken (v)
{
}

LengthUnitEnumType::
LengthUnitEnumType (const LengthUnitEnumType& v,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::nmtoken (v, f, c)
{
}

LengthUnitEnumType& LengthUnitEnumType::
operator= (value v)
{
  static_cast< ::xml_schema::nmtoken& > (*this) = 
  ::xml_schema::nmtoken (_xsd_LengthUnitEnumType_literals_[v]);

  return *this;
}


// PointType
// 

const PointType::X_type& PointType::
X () const
{
  return this->X_.get ();
}

PointType::X_type& PointType::
X ()
{
  return this->X_.get ();
}

void PointType::
X (const X_type& x)
{
  this->X_.set (x);
}

const PointType::Y_type& PointType::
Y () const
{
  return this->Y_.get ();
}

PointType::Y_type& PointType::
Y ()
{
  return this->Y_.get ();
}

void PointType::
Y (const Y_type& x)
{
  this->Y_.set (x);
}

const PointType::Z_type& PointType::
Z () const
{
  return this->Z_.get ();
}

PointType::Z_type& PointType::
Z ()
{
  return this->Z_.get ();
}

void PointType::
Z (const Z_type& x)
{
  this->Z_.set (x);
}


// PoseType
// 

const PoseType::Point_type& PoseType::
Point () const
{
  return this->Point_.get ();
}

PoseType::Point_type& PoseType::
Point ()
{
  return this->Point_.get ();
}

void PoseType::
Point (const Point_type& x)
{
  this->Point_.set (x);
}

void PoseType::
Point (::std::auto_ptr< Point_type > x)
{
  this->Point_.set (x);
}

const PoseType::XAxis_type& PoseType::
XAxis () const
{
  return this->XAxis_.get ();
}

PoseType::XAxis_type& PoseType::
XAxis ()
{
  return this->XAxis_.get ();
}

void PoseType::
XAxis (const XAxis_type& x)
{
  this->XAxis_.set (x);
}

void PoseType::
XAxis (::std::auto_ptr< XAxis_type > x)
{
  this->XAxis_.set (x);
}

const PoseType::ZAxis_type& PoseType::
ZAxis () const
{
  return this->ZAxis_.get ();
}

PoseType::ZAxis_type& PoseType::
ZAxis ()
{
  return this->ZAxis_.get ();
}

void PoseType::
ZAxis (const ZAxis_type& x)
{
  this->ZAxis_.set (x);
}

void PoseType::
ZAxis (::std::auto_ptr< ZAxis_type > x)
{
  this->ZAxis_.set (x);
}


// PositiveDecimalType
// 


// TorqueUnitEnumType
// 

TorqueUnitEnumType::
TorqueUnitEnumType (value v)
: ::xml_schema::nmtoken (_xsd_TorqueUnitEnumType_literals_[v])
{
}

TorqueUnitEnumType::
TorqueUnitEnumType (const char* v)
: ::xml_schema::nmtoken (v)
{
}

TorqueUnitEnumType::
TorqueUnitEnumType (const ::std::string& v)
: ::xml_schema::nmtoken (v)
{
}

TorqueUnitEnumType::
TorqueUnitEnumType (const ::xml_schema::nmtoken& v)
: ::xml_schema::nmtoken (v)
{
}

TorqueUnitEnumType::
TorqueUnitEnumType (const TorqueUnitEnumType& v,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::nmtoken (v, f, c)
{
}

TorqueUnitEnumType& TorqueUnitEnumType::
operator= (value v)
{
  static_cast< ::xml_schema::nmtoken& > (*this) = 
  ::xml_schema::nmtoken (_xsd_TorqueUnitEnumType_literals_[v]);

  return *this;
}


// TwistType
// 

const TwistType::LinearVelocity_type& TwistType::
LinearVelocity () const
{
  return this->LinearVelocity_.get ();
}

TwistType::LinearVelocity_type& TwistType::
LinearVelocity ()
{
  return this->LinearVelocity_.get ();
}

void TwistType::
LinearVelocity (const LinearVelocity_type& x)
{
  this->LinearVelocity_.set (x);
}

void TwistType::
LinearVelocity (::std::auto_ptr< LinearVelocity_type > x)
{
  this->LinearVelocity_.set (x);
}

const TwistType::AngularVelocity_type& TwistType::
AngularVelocity () const
{
  return this->AngularVelocity_.get ();
}

TwistType::AngularVelocity_type& TwistType::
AngularVelocity ()
{
  return this->AngularVelocity_.get ();
}

void TwistType::
AngularVelocity (const AngularVelocity_type& x)
{
  this->AngularVelocity_.set (x);
}

void TwistType::
AngularVelocity (::std::auto_ptr< AngularVelocity_type > x)
{
  this->AngularVelocity_.set (x);
}


// VectorType
// 

const VectorType::I_type& VectorType::
I () const
{
  return this->I_.get ();
}

VectorType::I_type& VectorType::
I ()
{
  return this->I_.get ();
}

void VectorType::
I (const I_type& x)
{
  this->I_.set (x);
}

const VectorType::J_type& VectorType::
J () const
{
  return this->J_.get ();
}

VectorType::J_type& VectorType::
J ()
{
  return this->J_.get ();
}

void VectorType::
J (const J_type& x)
{
  this->J_.set (x);
}

const VectorType::K_type& VectorType::
K () const
{
  return this->K_.get ();
}

VectorType::K_type& VectorType::
K ()
{
  return this->K_.get ();
}

void VectorType::
K (const K_type& x)
{
  this->K_.set (x);
}


// WrenchType
// 

const WrenchType::Force_type& WrenchType::
Force () const
{
  return this->Force_.get ();
}

WrenchType::Force_type& WrenchType::
Force ()
{
  return this->Force_.get ();
}

void WrenchType::
Force (const Force_type& x)
{
  this->Force_.set (x);
}

void WrenchType::
Force (::std::auto_ptr< Force_type > x)
{
  this->Force_.set (x);
}

const WrenchType::Moment_type& WrenchType::
Moment () const
{
  return this->Moment_.get ();
}

WrenchType::Moment_type& WrenchType::
Moment ()
{
  return this->Moment_.get ();
}

void WrenchType::
Moment (const Moment_type& x)
{
  this->Moment_.set (x);
}

void WrenchType::
Moment (::std::auto_ptr< Moment_type > x)
{
  this->Moment_.set (x);
}


// PoseToleranceType
// 

const PoseToleranceType::XPointTolerance_optional& PoseToleranceType::
XPointTolerance () const
{
  return this->XPointTolerance_;
}

PoseToleranceType::XPointTolerance_optional& PoseToleranceType::
XPointTolerance ()
{
  return this->XPointTolerance_;
}

void PoseToleranceType::
XPointTolerance (const XPointTolerance_type& x)
{
  this->XPointTolerance_.set (x);
}

void PoseToleranceType::
XPointTolerance (const XPointTolerance_optional& x)
{
  this->XPointTolerance_ = x;
}

const PoseToleranceType::YPointTolerance_optional& PoseToleranceType::
YPointTolerance () const
{
  return this->YPointTolerance_;
}

PoseToleranceType::YPointTolerance_optional& PoseToleranceType::
YPointTolerance ()
{
  return this->YPointTolerance_;
}

void PoseToleranceType::
YPointTolerance (const YPointTolerance_type& x)
{
  this->YPointTolerance_.set (x);
}

void PoseToleranceType::
YPointTolerance (const YPointTolerance_optional& x)
{
  this->YPointTolerance_ = x;
}

const PoseToleranceType::ZPointTolerance_optional& PoseToleranceType::
ZPointTolerance () const
{
  return this->ZPointTolerance_;
}

PoseToleranceType::ZPointTolerance_optional& PoseToleranceType::
ZPointTolerance ()
{
  return this->ZPointTolerance_;
}

void PoseToleranceType::
ZPointTolerance (const ZPointTolerance_type& x)
{
  this->ZPointTolerance_.set (x);
}

void PoseToleranceType::
ZPointTolerance (const ZPointTolerance_optional& x)
{
  this->ZPointTolerance_ = x;
}

const PoseToleranceType::XAxisTolerance_optional& PoseToleranceType::
XAxisTolerance () const
{
  return this->XAxisTolerance_;
}

PoseToleranceType::XAxisTolerance_optional& PoseToleranceType::
XAxisTolerance ()
{
  return this->XAxisTolerance_;
}

void PoseToleranceType::
XAxisTolerance (const XAxisTolerance_type& x)
{
  this->XAxisTolerance_.set (x);
}

void PoseToleranceType::
XAxisTolerance (const XAxisTolerance_optional& x)
{
  this->XAxisTolerance_ = x;
}

const PoseToleranceType::ZAxisTolerance_optional& PoseToleranceType::
ZAxisTolerance () const
{
  return this->ZAxisTolerance_;
}

PoseToleranceType::ZAxisTolerance_optional& PoseToleranceType::
ZAxisTolerance ()
{
  return this->ZAxisTolerance_;
}

void PoseToleranceType::
ZAxisTolerance (const ZAxisTolerance_type& x)
{
  this->ZAxisTolerance_.set (x);
}

void PoseToleranceType::
ZAxisTolerance (const ZAxisTolerance_optional& x)
{
  this->ZAxisTolerance_ = x;
}


// ParameterSettingType
// 

const ParameterSettingType::ParameterName_type& ParameterSettingType::
ParameterName () const
{
  return this->ParameterName_.get ();
}

ParameterSettingType::ParameterName_type& ParameterSettingType::
ParameterName ()
{
  return this->ParameterName_.get ();
}

void ParameterSettingType::
ParameterName (const ParameterName_type& x)
{
  this->ParameterName_.set (x);
}

void ParameterSettingType::
ParameterName (::std::auto_ptr< ParameterName_type > x)
{
  this->ParameterName_.set (x);
}

const ParameterSettingType::ParameterValue_type& ParameterSettingType::
ParameterValue () const
{
  return this->ParameterValue_.get ();
}

ParameterSettingType::ParameterValue_type& ParameterSettingType::
ParameterValue ()
{
  return this->ParameterValue_.get ();
}

void ParameterSettingType::
ParameterValue (const ParameterValue_type& x)
{
  this->ParameterValue_.set (x);
}

void ParameterSettingType::
ParameterValue (::std::auto_ptr< ParameterValue_type > x)
{
  this->ParameterValue_.set (x);
}


// RotAccelType
// 


// RotAccelAbsoluteType
// 

const RotAccelAbsoluteType::Setting_type& RotAccelAbsoluteType::
Setting () const
{
  return this->Setting_.get ();
}

RotAccelAbsoluteType::Setting_type& RotAccelAbsoluteType::
Setting ()
{
  return this->Setting_.get ();
}

void RotAccelAbsoluteType::
Setting (const Setting_type& x)
{
  this->Setting_.set (x);
}


// RotAccelRelativeType
// 

const RotAccelRelativeType::Fraction_type& RotAccelRelativeType::
Fraction () const
{
  return this->Fraction_.get ();
}

RotAccelRelativeType::Fraction_type& RotAccelRelativeType::
Fraction ()
{
  return this->Fraction_.get ();
}

void RotAccelRelativeType::
Fraction (const Fraction_type& x)
{
  this->Fraction_.set (x);
}

void RotAccelRelativeType::
Fraction (::std::auto_ptr< Fraction_type > x)
{
  this->Fraction_.set (x);
}


// RotSpeedType
// 


// RotSpeedAbsoluteType
// 

const RotSpeedAbsoluteType::Setting_type& RotSpeedAbsoluteType::
Setting () const
{
  return this->Setting_.get ();
}

RotSpeedAbsoluteType::Setting_type& RotSpeedAbsoluteType::
Setting ()
{
  return this->Setting_.get ();
}

void RotSpeedAbsoluteType::
Setting (const Setting_type& x)
{
  this->Setting_.set (x);
}


// RotSpeedRelativeType
// 

const RotSpeedRelativeType::Fraction_type& RotSpeedRelativeType::
Fraction () const
{
  return this->Fraction_.get ();
}

RotSpeedRelativeType::Fraction_type& RotSpeedRelativeType::
Fraction ()
{
  return this->Fraction_.get ();
}

void RotSpeedRelativeType::
Fraction (const Fraction_type& x)
{
  this->Fraction_.set (x);
}

void RotSpeedRelativeType::
Fraction (::std::auto_ptr< Fraction_type > x)
{
  this->Fraction_.set (x);
}


// TransAccelType
// 


// TransAccelAbsoluteType
// 

const TransAccelAbsoluteType::Setting_type& TransAccelAbsoluteType::
Setting () const
{
  return this->Setting_.get ();
}

TransAccelAbsoluteType::Setting_type& TransAccelAbsoluteType::
Setting ()
{
  return this->Setting_.get ();
}

void TransAccelAbsoluteType::
Setting (const Setting_type& x)
{
  this->Setting_.set (x);
}


// TransAccelRelativeType
// 

const TransAccelRelativeType::Fraction_type& TransAccelRelativeType::
Fraction () const
{
  return this->Fraction_.get ();
}

TransAccelRelativeType::Fraction_type& TransAccelRelativeType::
Fraction ()
{
  return this->Fraction_.get ();
}

void TransAccelRelativeType::
Fraction (const Fraction_type& x)
{
  this->Fraction_.set (x);
}

void TransAccelRelativeType::
Fraction (::std::auto_ptr< Fraction_type > x)
{
  this->Fraction_.set (x);
}


// TransSpeedType
// 


// TransSpeedAbsoluteType
// 

const TransSpeedAbsoluteType::Setting_type& TransSpeedAbsoluteType::
Setting () const
{
  return this->Setting_.get ();
}

TransSpeedAbsoluteType::Setting_type& TransSpeedAbsoluteType::
Setting ()
{
  return this->Setting_.get ();
}

void TransSpeedAbsoluteType::
Setting (const Setting_type& x)
{
  this->Setting_.set (x);
}


// TransSpeedRelativeType
// 

const TransSpeedRelativeType::Fraction_type& TransSpeedRelativeType::
Fraction () const
{
  return this->Fraction_.get ();
}

TransSpeedRelativeType::Fraction_type& TransSpeedRelativeType::
Fraction ()
{
  return this->Fraction_.get ();
}

void TransSpeedRelativeType::
Fraction (const Fraction_type& x)
{
  this->Fraction_.set (x);
}

void TransSpeedRelativeType::
Fraction (::std::auto_ptr< Fraction_type > x)
{
  this->Fraction_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

// AngleUnitEnumType
//

AngleUnitEnumType::
AngleUnitEnumType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::nmtoken (e, f, c)
{
  _xsd_AngleUnitEnumType_convert ();
}

AngleUnitEnumType::
AngleUnitEnumType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::nmtoken (a, f, c)
{
  _xsd_AngleUnitEnumType_convert ();
}

AngleUnitEnumType::
AngleUnitEnumType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::nmtoken (s, e, f, c)
{
  _xsd_AngleUnitEnumType_convert ();
}

AngleUnitEnumType* AngleUnitEnumType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class AngleUnitEnumType (*this, f, c);
}

AngleUnitEnumType::value AngleUnitEnumType::
_xsd_AngleUnitEnumType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_AngleUnitEnumType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_AngleUnitEnumType_indexes_,
                    _xsd_AngleUnitEnumType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_AngleUnitEnumType_indexes_ + 2 || _xsd_AngleUnitEnumType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const AngleUnitEnumType::
_xsd_AngleUnitEnumType_literals_[2] =
{
  "degree",
  "radian"
};

const AngleUnitEnumType::value AngleUnitEnumType::
_xsd_AngleUnitEnumType_indexes_[2] =
{
  ::AngleUnitEnumType::degree,
  ::AngleUnitEnumType::radian
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, AngleUnitEnumType >
_xsd_AngleUnitEnumType_type_factory_init (
  "AngleUnitEnumType",
  "");

// DataThingType
//

DataThingType::
DataThingType ()
: ::xml_schema::type (),
  Name_ (this)
{
}

DataThingType::
DataThingType (const DataThingType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Name_ (x.Name_, f, this)
{
}

DataThingType::
DataThingType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void DataThingType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Name
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Name",
          "",
          &::xsd::cxx::tree::factory_impl< Name_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Name_)
        {
          ::std::auto_ptr< Name_type > r (
            dynamic_cast< Name_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Name_.set (r);
          continue;
        }
      }
    }

    break;
  }
}

DataThingType* DataThingType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DataThingType (*this, f, c);
}

DataThingType& DataThingType::
operator= (const DataThingType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Name_ = x.Name_;
  }

  return *this;
}

DataThingType::
~DataThingType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, DataThingType >
_xsd_DataThingType_type_factory_init (
  "DataThingType",
  "");

// ForceUnitEnumType
//

ForceUnitEnumType::
ForceUnitEnumType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::nmtoken (e, f, c)
{
  _xsd_ForceUnitEnumType_convert ();
}

ForceUnitEnumType::
ForceUnitEnumType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::nmtoken (a, f, c)
{
  _xsd_ForceUnitEnumType_convert ();
}

ForceUnitEnumType::
ForceUnitEnumType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::nmtoken (s, e, f, c)
{
  _xsd_ForceUnitEnumType_convert ();
}

ForceUnitEnumType* ForceUnitEnumType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ForceUnitEnumType (*this, f, c);
}

ForceUnitEnumType::value ForceUnitEnumType::
_xsd_ForceUnitEnumType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ForceUnitEnumType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_ForceUnitEnumType_indexes_,
                    _xsd_ForceUnitEnumType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_ForceUnitEnumType_indexes_ + 3 || _xsd_ForceUnitEnumType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const ForceUnitEnumType::
_xsd_ForceUnitEnumType_literals_[3] =
{
  "newton",
  "pound",
  "ounce"
};

const ForceUnitEnumType::value ForceUnitEnumType::
_xsd_ForceUnitEnumType_indexes_[3] =
{
  ::ForceUnitEnumType::newton,
  ::ForceUnitEnumType::ounce,
  ::ForceUnitEnumType::pound
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ForceUnitEnumType >
_xsd_ForceUnitEnumType_type_factory_init (
  "ForceUnitEnumType",
  "");

// FractionType
//

FractionType::
FractionType (const ::xml_schema::double_& _xsd_double__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
{
}

FractionType::
FractionType (const FractionType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
{
}

FractionType::
FractionType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
{
}

FractionType::
FractionType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
{
}

FractionType::
FractionType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
{
}

FractionType* FractionType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class FractionType (*this, f, c);
}

FractionType::
~FractionType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, FractionType >
_xsd_FractionType_type_factory_init (
  "FractionType",
  "");

// LengthUnitEnumType
//

LengthUnitEnumType::
LengthUnitEnumType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::nmtoken (e, f, c)
{
  _xsd_LengthUnitEnumType_convert ();
}

LengthUnitEnumType::
LengthUnitEnumType (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::nmtoken (a, f, c)
{
  _xsd_LengthUnitEnumType_convert ();
}

LengthUnitEnumType::
LengthUnitEnumType (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::nmtoken (s, e, f, c)
{
  _xsd_LengthUnitEnumType_convert ();
}

LengthUnitEnumType* LengthUnitEnumType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class LengthUnitEnumType (*this, f, c);
}

LengthUnitEnumType::value LengthUnitEnumType::
_xsd_LengthUnitEnumType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_LengthUnitEnumType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_LengthUnitEnumType_indexes_,
                    _xsd_LengthUnitEnumType_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_LengthUnitEnumType_indexes_ + 3 || _xsd_LengthUnitEnumType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const LengthUnitEnumType::
_xsd_LengthUnitEnumType_literals_[3] =
{
  "meter",
  "millimeter",
  "inch"
};

const LengthUnitEnumType::value LengthUnitEnumType::
_xsd_LengthUnitEnumType_indexes_[3] =
{
  ::LengthUnitEnumType::inch,
  ::LengthUnitEnumType::meter,
  ::LengthUnitEnumType::millimeter
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, LengthUnitEnumType >
_xsd_LengthUnitEnumType_type_factory_init (
  "LengthUnitEnumType",
  "");

// PointType
//

PointType::
PointType (const X_type& X,
           const Y_type& Y,
           const Z_type& Z)
: ::DataThingType (),
  X_ (X, this),
  Y_ (Y, this),
  Z_ (Z, this)
{
}

PointType::
PointType (const PointType& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  X_ (x.X_, f, this),
  Y_ (x.Y_, f, this),
  Z_ (x.Z_, f, this)
{
}

PointType::
PointType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  X_ (this),
  Y_ (this),
  Z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void PointType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // X
    //
    if (n.name () == "X" && n.namespace_ ().empty ())
    {
      if (!X_.present ())
      {
        this->X_.set (X_traits::create (i, f, this));
        continue;
      }
    }

    // Y
    //
    if (n.name () == "Y" && n.namespace_ ().empty ())
    {
      if (!Y_.present ())
      {
        this->Y_.set (Y_traits::create (i, f, this));
        continue;
      }
    }

    // Z
    //
    if (n.name () == "Z" && n.namespace_ ().empty ())
    {
      if (!Z_.present ())
      {
        this->Z_.set (Z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!X_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "X",
      "");
  }

  if (!Y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Y",
      "");
  }

  if (!Z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Z",
      "");
  }
}

PointType* PointType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PointType (*this, f, c);
}

PointType& PointType::
operator= (const PointType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->X_ = x.X_;
    this->Y_ = x.Y_;
    this->Z_ = x.Z_;
  }

  return *this;
}

PointType::
~PointType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, PointType >
_xsd_PointType_type_factory_init (
  "PointType",
  "");

// PoseType
//

PoseType::
PoseType (const Point_type& Point,
          const XAxis_type& XAxis,
          const ZAxis_type& ZAxis)
: ::DataThingType (),
  Point_ (Point, this),
  XAxis_ (XAxis, this),
  ZAxis_ (ZAxis, this)
{
}

PoseType::
PoseType (::std::auto_ptr< Point_type > Point,
          ::std::auto_ptr< XAxis_type > XAxis,
          ::std::auto_ptr< ZAxis_type > ZAxis)
: ::DataThingType (),
  Point_ (Point, this),
  XAxis_ (XAxis, this),
  ZAxis_ (ZAxis, this)
{
}

PoseType::
PoseType (const PoseType& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  Point_ (x.Point_, f, this),
  XAxis_ (x.XAxis_, f, this),
  ZAxis_ (x.ZAxis_, f, this)
{
}

PoseType::
PoseType (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  Point_ (this),
  XAxis_ (this),
  ZAxis_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void PoseType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Point
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Point",
          "",
          &::xsd::cxx::tree::factory_impl< Point_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Point_.present ())
        {
          ::std::auto_ptr< Point_type > r (
            dynamic_cast< Point_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Point_.set (r);
          continue;
        }
      }
    }

    // XAxis
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "XAxis",
          "",
          &::xsd::cxx::tree::factory_impl< XAxis_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!XAxis_.present ())
        {
          ::std::auto_ptr< XAxis_type > r (
            dynamic_cast< XAxis_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->XAxis_.set (r);
          continue;
        }
      }
    }

    // ZAxis
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ZAxis",
          "",
          &::xsd::cxx::tree::factory_impl< ZAxis_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!ZAxis_.present ())
        {
          ::std::auto_ptr< ZAxis_type > r (
            dynamic_cast< ZAxis_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ZAxis_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Point_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Point",
      "");
  }

  if (!XAxis_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "XAxis",
      "");
  }

  if (!ZAxis_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ZAxis",
      "");
  }
}

PoseType* PoseType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PoseType (*this, f, c);
}

PoseType& PoseType::
operator= (const PoseType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->Point_ = x.Point_;
    this->XAxis_ = x.XAxis_;
    this->ZAxis_ = x.ZAxis_;
  }

  return *this;
}

PoseType::
~PoseType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, PoseType >
_xsd_PoseType_type_factory_init (
  "PoseType",
  "");

// PositiveDecimalType
//

PositiveDecimalType::
PositiveDecimalType (const ::xml_schema::double_& _xsd_double__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
{
}

PositiveDecimalType::
PositiveDecimalType (const PositiveDecimalType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
{
}

PositiveDecimalType::
PositiveDecimalType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
{
}

PositiveDecimalType::
PositiveDecimalType (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
{
}

PositiveDecimalType::
PositiveDecimalType (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
{
}

PositiveDecimalType* PositiveDecimalType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PositiveDecimalType (*this, f, c);
}

PositiveDecimalType::
~PositiveDecimalType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, PositiveDecimalType >
_xsd_PositiveDecimalType_type_factory_init (
  "PositiveDecimalType",
  "");

// TorqueUnitEnumType
//

TorqueUnitEnumType::
TorqueUnitEnumType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::nmtoken (e, f, c)
{
  _xsd_TorqueUnitEnumType_convert ();
}

TorqueUnitEnumType::
TorqueUnitEnumType (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::nmtoken (a, f, c)
{
  _xsd_TorqueUnitEnumType_convert ();
}

TorqueUnitEnumType::
TorqueUnitEnumType (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::nmtoken (s, e, f, c)
{
  _xsd_TorqueUnitEnumType_convert ();
}

TorqueUnitEnumType* TorqueUnitEnumType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TorqueUnitEnumType (*this, f, c);
}

TorqueUnitEnumType::value TorqueUnitEnumType::
_xsd_TorqueUnitEnumType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_TorqueUnitEnumType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_TorqueUnitEnumType_indexes_,
                    _xsd_TorqueUnitEnumType_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_TorqueUnitEnumType_indexes_ + 2 || _xsd_TorqueUnitEnumType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const TorqueUnitEnumType::
_xsd_TorqueUnitEnumType_literals_[2] =
{
  "newtonMeter",
  "footPound"
};

const TorqueUnitEnumType::value TorqueUnitEnumType::
_xsd_TorqueUnitEnumType_indexes_[2] =
{
  ::TorqueUnitEnumType::footPound,
  ::TorqueUnitEnumType::newtonMeter
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, TorqueUnitEnumType >
_xsd_TorqueUnitEnumType_type_factory_init (
  "TorqueUnitEnumType",
  "");

// TwistType
//

TwistType::
TwistType (const LinearVelocity_type& LinearVelocity,
           const AngularVelocity_type& AngularVelocity)
: ::DataThingType (),
  LinearVelocity_ (LinearVelocity, this),
  AngularVelocity_ (AngularVelocity, this)
{
}

TwistType::
TwistType (::std::auto_ptr< LinearVelocity_type > LinearVelocity,
           ::std::auto_ptr< AngularVelocity_type > AngularVelocity)
: ::DataThingType (),
  LinearVelocity_ (LinearVelocity, this),
  AngularVelocity_ (AngularVelocity, this)
{
}

TwistType::
TwistType (const TwistType& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  LinearVelocity_ (x.LinearVelocity_, f, this),
  AngularVelocity_ (x.AngularVelocity_, f, this)
{
}

TwistType::
TwistType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  LinearVelocity_ (this),
  AngularVelocity_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void TwistType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // LinearVelocity
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "LinearVelocity",
          "",
          &::xsd::cxx::tree::factory_impl< LinearVelocity_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!LinearVelocity_.present ())
        {
          ::std::auto_ptr< LinearVelocity_type > r (
            dynamic_cast< LinearVelocity_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->LinearVelocity_.set (r);
          continue;
        }
      }
    }

    // AngularVelocity
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "AngularVelocity",
          "",
          &::xsd::cxx::tree::factory_impl< AngularVelocity_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!AngularVelocity_.present ())
        {
          ::std::auto_ptr< AngularVelocity_type > r (
            dynamic_cast< AngularVelocity_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->AngularVelocity_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!LinearVelocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "LinearVelocity",
      "");
  }

  if (!AngularVelocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "AngularVelocity",
      "");
  }
}

TwistType* TwistType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TwistType (*this, f, c);
}

TwistType& TwistType::
operator= (const TwistType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->LinearVelocity_ = x.LinearVelocity_;
    this->AngularVelocity_ = x.AngularVelocity_;
  }

  return *this;
}

TwistType::
~TwistType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, TwistType >
_xsd_TwistType_type_factory_init (
  "TwistType",
  "");

// VectorType
//

VectorType::
VectorType (const I_type& I,
            const J_type& J,
            const K_type& K)
: ::DataThingType (),
  I_ (I, this),
  J_ (J, this),
  K_ (K, this)
{
}

VectorType::
VectorType (const VectorType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  I_ (x.I_, f, this),
  J_ (x.J_, f, this),
  K_ (x.K_, f, this)
{
}

VectorType::
VectorType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  I_ (this),
  J_ (this),
  K_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void VectorType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // I
    //
    if (n.name () == "I" && n.namespace_ ().empty ())
    {
      if (!I_.present ())
      {
        this->I_.set (I_traits::create (i, f, this));
        continue;
      }
    }

    // J
    //
    if (n.name () == "J" && n.namespace_ ().empty ())
    {
      if (!J_.present ())
      {
        this->J_.set (J_traits::create (i, f, this));
        continue;
      }
    }

    // K
    //
    if (n.name () == "K" && n.namespace_ ().empty ())
    {
      if (!K_.present ())
      {
        this->K_.set (K_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!I_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "I",
      "");
  }

  if (!J_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "J",
      "");
  }

  if (!K_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "K",
      "");
  }
}

VectorType* VectorType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class VectorType (*this, f, c);
}

VectorType& VectorType::
operator= (const VectorType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->I_ = x.I_;
    this->J_ = x.J_;
    this->K_ = x.K_;
  }

  return *this;
}

VectorType::
~VectorType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, VectorType >
_xsd_VectorType_type_factory_init (
  "VectorType",
  "");

// WrenchType
//

WrenchType::
WrenchType (const Force_type& Force,
            const Moment_type& Moment)
: ::DataThingType (),
  Force_ (Force, this),
  Moment_ (Moment, this)
{
}

WrenchType::
WrenchType (::std::auto_ptr< Force_type > Force,
            ::std::auto_ptr< Moment_type > Moment)
: ::DataThingType (),
  Force_ (Force, this),
  Moment_ (Moment, this)
{
}

WrenchType::
WrenchType (const WrenchType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  Force_ (x.Force_, f, this),
  Moment_ (x.Moment_, f, this)
{
}

WrenchType::
WrenchType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  Force_ (this),
  Moment_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void WrenchType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Force
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Force",
          "",
          &::xsd::cxx::tree::factory_impl< Force_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Force_.present ())
        {
          ::std::auto_ptr< Force_type > r (
            dynamic_cast< Force_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Force_.set (r);
          continue;
        }
      }
    }

    // Moment
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Moment",
          "",
          &::xsd::cxx::tree::factory_impl< Moment_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Moment_.present ())
        {
          ::std::auto_ptr< Moment_type > r (
            dynamic_cast< Moment_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Moment_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Force_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Force",
      "");
  }

  if (!Moment_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Moment",
      "");
  }
}

WrenchType* WrenchType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class WrenchType (*this, f, c);
}

WrenchType& WrenchType::
operator= (const WrenchType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->Force_ = x.Force_;
    this->Moment_ = x.Moment_;
  }

  return *this;
}

WrenchType::
~WrenchType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, WrenchType >
_xsd_WrenchType_type_factory_init (
  "WrenchType",
  "");

// PoseToleranceType
//

PoseToleranceType::
PoseToleranceType ()
: ::DataThingType (),
  XPointTolerance_ (this),
  YPointTolerance_ (this),
  ZPointTolerance_ (this),
  XAxisTolerance_ (this),
  ZAxisTolerance_ (this)
{
}

PoseToleranceType::
PoseToleranceType (const PoseToleranceType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  XPointTolerance_ (x.XPointTolerance_, f, this),
  YPointTolerance_ (x.YPointTolerance_, f, this),
  ZPointTolerance_ (x.ZPointTolerance_, f, this),
  XAxisTolerance_ (x.XAxisTolerance_, f, this),
  ZAxisTolerance_ (x.ZAxisTolerance_, f, this)
{
}

PoseToleranceType::
PoseToleranceType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  XPointTolerance_ (this),
  YPointTolerance_ (this),
  ZPointTolerance_ (this),
  XAxisTolerance_ (this),
  ZAxisTolerance_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void PoseToleranceType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // XPointTolerance
    //
    if (n.name () == "XPointTolerance" && n.namespace_ ().empty ())
    {
      if (!this->XPointTolerance_)
      {
        this->XPointTolerance_.set (XPointTolerance_traits::create (i, f, this));
        continue;
      }
    }

    // YPointTolerance
    //
    if (n.name () == "YPointTolerance" && n.namespace_ ().empty ())
    {
      if (!this->YPointTolerance_)
      {
        this->YPointTolerance_.set (YPointTolerance_traits::create (i, f, this));
        continue;
      }
    }

    // ZPointTolerance
    //
    if (n.name () == "ZPointTolerance" && n.namespace_ ().empty ())
    {
      if (!this->ZPointTolerance_)
      {
        this->ZPointTolerance_.set (ZPointTolerance_traits::create (i, f, this));
        continue;
      }
    }

    // XAxisTolerance
    //
    if (n.name () == "XAxisTolerance" && n.namespace_ ().empty ())
    {
      if (!this->XAxisTolerance_)
      {
        this->XAxisTolerance_.set (XAxisTolerance_traits::create (i, f, this));
        continue;
      }
    }

    // ZAxisTolerance
    //
    if (n.name () == "ZAxisTolerance" && n.namespace_ ().empty ())
    {
      if (!this->ZAxisTolerance_)
      {
        this->ZAxisTolerance_.set (ZAxisTolerance_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

PoseToleranceType* PoseToleranceType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PoseToleranceType (*this, f, c);
}

PoseToleranceType& PoseToleranceType::
operator= (const PoseToleranceType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->XPointTolerance_ = x.XPointTolerance_;
    this->YPointTolerance_ = x.YPointTolerance_;
    this->ZPointTolerance_ = x.ZPointTolerance_;
    this->XAxisTolerance_ = x.XAxisTolerance_;
    this->ZAxisTolerance_ = x.ZAxisTolerance_;
  }

  return *this;
}

PoseToleranceType::
~PoseToleranceType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, PoseToleranceType >
_xsd_PoseToleranceType_type_factory_init (
  "PoseToleranceType",
  "");

// ParameterSettingType
//

ParameterSettingType::
ParameterSettingType (const ParameterName_type& ParameterName,
                      const ParameterValue_type& ParameterValue)
: ::DataThingType (),
  ParameterName_ (ParameterName, this),
  ParameterValue_ (ParameterValue, this)
{
}

ParameterSettingType::
ParameterSettingType (::std::auto_ptr< ParameterName_type > ParameterName,
                      ::std::auto_ptr< ParameterValue_type > ParameterValue)
: ::DataThingType (),
  ParameterName_ (ParameterName, this),
  ParameterValue_ (ParameterValue, this)
{
}

ParameterSettingType::
ParameterSettingType (const ParameterSettingType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  ParameterName_ (x.ParameterName_, f, this),
  ParameterValue_ (x.ParameterValue_, f, this)
{
}

ParameterSettingType::
ParameterSettingType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  ParameterName_ (this),
  ParameterValue_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ParameterSettingType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ParameterName
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ParameterName",
          "",
          &::xsd::cxx::tree::factory_impl< ParameterName_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!ParameterName_.present ())
        {
          ::std::auto_ptr< ParameterName_type > r (
            dynamic_cast< ParameterName_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ParameterName_.set (r);
          continue;
        }
      }
    }

    // ParameterValue
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ParameterValue",
          "",
          &::xsd::cxx::tree::factory_impl< ParameterValue_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!ParameterValue_.present ())
        {
          ::std::auto_ptr< ParameterValue_type > r (
            dynamic_cast< ParameterValue_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ParameterValue_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!ParameterName_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ParameterName",
      "");
  }

  if (!ParameterValue_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ParameterValue",
      "");
  }
}

ParameterSettingType* ParameterSettingType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParameterSettingType (*this, f, c);
}

ParameterSettingType& ParameterSettingType::
operator= (const ParameterSettingType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->ParameterName_ = x.ParameterName_;
    this->ParameterValue_ = x.ParameterValue_;
  }

  return *this;
}

ParameterSettingType::
~ParameterSettingType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParameterSettingType >
_xsd_ParameterSettingType_type_factory_init (
  "ParameterSettingType",
  "");

// RotAccelType
//

RotAccelType::
RotAccelType ()
: ::DataThingType ()
{
}

RotAccelType::
RotAccelType (const RotAccelType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::DataThingType (x, f, c)
{
}

RotAccelType::
RotAccelType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::DataThingType (e, f, c)
{
}

RotAccelType* RotAccelType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RotAccelType (*this, f, c);
}

RotAccelType::
~RotAccelType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, RotAccelType >
_xsd_RotAccelType_type_factory_init (
  "RotAccelType",
  "");

// RotAccelAbsoluteType
//

RotAccelAbsoluteType::
RotAccelAbsoluteType (const Setting_type& Setting)
: ::RotAccelType (),
  Setting_ (Setting, this)
{
}

RotAccelAbsoluteType::
RotAccelAbsoluteType (const RotAccelAbsoluteType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::RotAccelType (x, f, c),
  Setting_ (x.Setting_, f, this)
{
}

RotAccelAbsoluteType::
RotAccelAbsoluteType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::RotAccelType (e, f | ::xml_schema::flags::base, c),
  Setting_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RotAccelAbsoluteType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RotAccelType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Setting
    //
    if (n.name () == "Setting" && n.namespace_ ().empty ())
    {
      if (!Setting_.present ())
      {
        this->Setting_.set (Setting_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!Setting_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Setting",
      "");
  }
}

RotAccelAbsoluteType* RotAccelAbsoluteType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RotAccelAbsoluteType (*this, f, c);
}

RotAccelAbsoluteType& RotAccelAbsoluteType::
operator= (const RotAccelAbsoluteType& x)
{
  if (this != &x)
  {
    static_cast< ::RotAccelType& > (*this) = x;
    this->Setting_ = x.Setting_;
  }

  return *this;
}

RotAccelAbsoluteType::
~RotAccelAbsoluteType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, RotAccelAbsoluteType >
_xsd_RotAccelAbsoluteType_type_factory_init (
  "RotAccelAbsoluteType",
  "");

// RotAccelRelativeType
//

RotAccelRelativeType::
RotAccelRelativeType (const Fraction_type& Fraction)
: ::RotAccelType (),
  Fraction_ (Fraction, this)
{
}

RotAccelRelativeType::
RotAccelRelativeType (::std::auto_ptr< Fraction_type > Fraction)
: ::RotAccelType (),
  Fraction_ (Fraction, this)
{
}

RotAccelRelativeType::
RotAccelRelativeType (const RotAccelRelativeType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::RotAccelType (x, f, c),
  Fraction_ (x.Fraction_, f, this)
{
}

RotAccelRelativeType::
RotAccelRelativeType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::RotAccelType (e, f | ::xml_schema::flags::base, c),
  Fraction_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RotAccelRelativeType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RotAccelType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Fraction
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Fraction",
          "",
          &::xsd::cxx::tree::factory_impl< Fraction_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Fraction_.present ())
        {
          ::std::auto_ptr< Fraction_type > r (
            dynamic_cast< Fraction_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Fraction_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Fraction_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Fraction",
      "");
  }
}

RotAccelRelativeType* RotAccelRelativeType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RotAccelRelativeType (*this, f, c);
}

RotAccelRelativeType& RotAccelRelativeType::
operator= (const RotAccelRelativeType& x)
{
  if (this != &x)
  {
    static_cast< ::RotAccelType& > (*this) = x;
    this->Fraction_ = x.Fraction_;
  }

  return *this;
}

RotAccelRelativeType::
~RotAccelRelativeType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, RotAccelRelativeType >
_xsd_RotAccelRelativeType_type_factory_init (
  "RotAccelRelativeType",
  "");

// RotSpeedType
//

RotSpeedType::
RotSpeedType ()
: ::DataThingType ()
{
}

RotSpeedType::
RotSpeedType (const RotSpeedType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::DataThingType (x, f, c)
{
}

RotSpeedType::
RotSpeedType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::DataThingType (e, f, c)
{
}

RotSpeedType* RotSpeedType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RotSpeedType (*this, f, c);
}

RotSpeedType::
~RotSpeedType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, RotSpeedType >
_xsd_RotSpeedType_type_factory_init (
  "RotSpeedType",
  "");

// RotSpeedAbsoluteType
//

RotSpeedAbsoluteType::
RotSpeedAbsoluteType (const Setting_type& Setting)
: ::RotSpeedType (),
  Setting_ (Setting, this)
{
}

RotSpeedAbsoluteType::
RotSpeedAbsoluteType (const RotSpeedAbsoluteType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::RotSpeedType (x, f, c),
  Setting_ (x.Setting_, f, this)
{
}

RotSpeedAbsoluteType::
RotSpeedAbsoluteType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::RotSpeedType (e, f | ::xml_schema::flags::base, c),
  Setting_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RotSpeedAbsoluteType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RotSpeedType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Setting
    //
    if (n.name () == "Setting" && n.namespace_ ().empty ())
    {
      if (!Setting_.present ())
      {
        this->Setting_.set (Setting_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!Setting_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Setting",
      "");
  }
}

RotSpeedAbsoluteType* RotSpeedAbsoluteType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RotSpeedAbsoluteType (*this, f, c);
}

RotSpeedAbsoluteType& RotSpeedAbsoluteType::
operator= (const RotSpeedAbsoluteType& x)
{
  if (this != &x)
  {
    static_cast< ::RotSpeedType& > (*this) = x;
    this->Setting_ = x.Setting_;
  }

  return *this;
}

RotSpeedAbsoluteType::
~RotSpeedAbsoluteType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, RotSpeedAbsoluteType >
_xsd_RotSpeedAbsoluteType_type_factory_init (
  "RotSpeedAbsoluteType",
  "");

// RotSpeedRelativeType
//

RotSpeedRelativeType::
RotSpeedRelativeType (const Fraction_type& Fraction)
: ::RotSpeedType (),
  Fraction_ (Fraction, this)
{
}

RotSpeedRelativeType::
RotSpeedRelativeType (::std::auto_ptr< Fraction_type > Fraction)
: ::RotSpeedType (),
  Fraction_ (Fraction, this)
{
}

RotSpeedRelativeType::
RotSpeedRelativeType (const RotSpeedRelativeType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::RotSpeedType (x, f, c),
  Fraction_ (x.Fraction_, f, this)
{
}

RotSpeedRelativeType::
RotSpeedRelativeType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::RotSpeedType (e, f | ::xml_schema::flags::base, c),
  Fraction_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void RotSpeedRelativeType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RotSpeedType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Fraction
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Fraction",
          "",
          &::xsd::cxx::tree::factory_impl< Fraction_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Fraction_.present ())
        {
          ::std::auto_ptr< Fraction_type > r (
            dynamic_cast< Fraction_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Fraction_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Fraction_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Fraction",
      "");
  }
}

RotSpeedRelativeType* RotSpeedRelativeType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RotSpeedRelativeType (*this, f, c);
}

RotSpeedRelativeType& RotSpeedRelativeType::
operator= (const RotSpeedRelativeType& x)
{
  if (this != &x)
  {
    static_cast< ::RotSpeedType& > (*this) = x;
    this->Fraction_ = x.Fraction_;
  }

  return *this;
}

RotSpeedRelativeType::
~RotSpeedRelativeType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, RotSpeedRelativeType >
_xsd_RotSpeedRelativeType_type_factory_init (
  "RotSpeedRelativeType",
  "");

// TransAccelType
//

TransAccelType::
TransAccelType ()
: ::DataThingType ()
{
}

TransAccelType::
TransAccelType (const TransAccelType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::DataThingType (x, f, c)
{
}

TransAccelType::
TransAccelType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::DataThingType (e, f, c)
{
}

TransAccelType* TransAccelType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TransAccelType (*this, f, c);
}

TransAccelType::
~TransAccelType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, TransAccelType >
_xsd_TransAccelType_type_factory_init (
  "TransAccelType",
  "");

// TransAccelAbsoluteType
//

TransAccelAbsoluteType::
TransAccelAbsoluteType (const Setting_type& Setting)
: ::TransAccelType (),
  Setting_ (Setting, this)
{
}

TransAccelAbsoluteType::
TransAccelAbsoluteType (const TransAccelAbsoluteType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::TransAccelType (x, f, c),
  Setting_ (x.Setting_, f, this)
{
}

TransAccelAbsoluteType::
TransAccelAbsoluteType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::TransAccelType (e, f | ::xml_schema::flags::base, c),
  Setting_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void TransAccelAbsoluteType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::TransAccelType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Setting
    //
    if (n.name () == "Setting" && n.namespace_ ().empty ())
    {
      if (!Setting_.present ())
      {
        this->Setting_.set (Setting_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!Setting_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Setting",
      "");
  }
}

TransAccelAbsoluteType* TransAccelAbsoluteType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TransAccelAbsoluteType (*this, f, c);
}

TransAccelAbsoluteType& TransAccelAbsoluteType::
operator= (const TransAccelAbsoluteType& x)
{
  if (this != &x)
  {
    static_cast< ::TransAccelType& > (*this) = x;
    this->Setting_ = x.Setting_;
  }

  return *this;
}

TransAccelAbsoluteType::
~TransAccelAbsoluteType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, TransAccelAbsoluteType >
_xsd_TransAccelAbsoluteType_type_factory_init (
  "TransAccelAbsoluteType",
  "");

// TransAccelRelativeType
//

TransAccelRelativeType::
TransAccelRelativeType (const Fraction_type& Fraction)
: ::TransAccelType (),
  Fraction_ (Fraction, this)
{
}

TransAccelRelativeType::
TransAccelRelativeType (::std::auto_ptr< Fraction_type > Fraction)
: ::TransAccelType (),
  Fraction_ (Fraction, this)
{
}

TransAccelRelativeType::
TransAccelRelativeType (const TransAccelRelativeType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::TransAccelType (x, f, c),
  Fraction_ (x.Fraction_, f, this)
{
}

TransAccelRelativeType::
TransAccelRelativeType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::TransAccelType (e, f | ::xml_schema::flags::base, c),
  Fraction_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void TransAccelRelativeType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::TransAccelType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Fraction
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Fraction",
          "",
          &::xsd::cxx::tree::factory_impl< Fraction_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Fraction_.present ())
        {
          ::std::auto_ptr< Fraction_type > r (
            dynamic_cast< Fraction_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Fraction_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Fraction_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Fraction",
      "");
  }
}

TransAccelRelativeType* TransAccelRelativeType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TransAccelRelativeType (*this, f, c);
}

TransAccelRelativeType& TransAccelRelativeType::
operator= (const TransAccelRelativeType& x)
{
  if (this != &x)
  {
    static_cast< ::TransAccelType& > (*this) = x;
    this->Fraction_ = x.Fraction_;
  }

  return *this;
}

TransAccelRelativeType::
~TransAccelRelativeType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, TransAccelRelativeType >
_xsd_TransAccelRelativeType_type_factory_init (
  "TransAccelRelativeType",
  "");

// TransSpeedType
//

TransSpeedType::
TransSpeedType ()
: ::DataThingType ()
{
}

TransSpeedType::
TransSpeedType (const TransSpeedType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::DataThingType (x, f, c)
{
}

TransSpeedType::
TransSpeedType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::DataThingType (e, f, c)
{
}

TransSpeedType* TransSpeedType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TransSpeedType (*this, f, c);
}

TransSpeedType::
~TransSpeedType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, TransSpeedType >
_xsd_TransSpeedType_type_factory_init (
  "TransSpeedType",
  "");

// TransSpeedAbsoluteType
//

TransSpeedAbsoluteType::
TransSpeedAbsoluteType (const Setting_type& Setting)
: ::TransSpeedType (),
  Setting_ (Setting, this)
{
}

TransSpeedAbsoluteType::
TransSpeedAbsoluteType (const TransSpeedAbsoluteType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::TransSpeedType (x, f, c),
  Setting_ (x.Setting_, f, this)
{
}

TransSpeedAbsoluteType::
TransSpeedAbsoluteType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::TransSpeedType (e, f | ::xml_schema::flags::base, c),
  Setting_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void TransSpeedAbsoluteType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::TransSpeedType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Setting
    //
    if (n.name () == "Setting" && n.namespace_ ().empty ())
    {
      if (!Setting_.present ())
      {
        this->Setting_.set (Setting_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!Setting_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Setting",
      "");
  }
}

TransSpeedAbsoluteType* TransSpeedAbsoluteType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TransSpeedAbsoluteType (*this, f, c);
}

TransSpeedAbsoluteType& TransSpeedAbsoluteType::
operator= (const TransSpeedAbsoluteType& x)
{
  if (this != &x)
  {
    static_cast< ::TransSpeedType& > (*this) = x;
    this->Setting_ = x.Setting_;
  }

  return *this;
}

TransSpeedAbsoluteType::
~TransSpeedAbsoluteType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, TransSpeedAbsoluteType >
_xsd_TransSpeedAbsoluteType_type_factory_init (
  "TransSpeedAbsoluteType",
  "");

// TransSpeedRelativeType
//

TransSpeedRelativeType::
TransSpeedRelativeType (const Fraction_type& Fraction)
: ::TransSpeedType (),
  Fraction_ (Fraction, this)
{
}

TransSpeedRelativeType::
TransSpeedRelativeType (::std::auto_ptr< Fraction_type > Fraction)
: ::TransSpeedType (),
  Fraction_ (Fraction, this)
{
}

TransSpeedRelativeType::
TransSpeedRelativeType (const TransSpeedRelativeType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::TransSpeedType (x, f, c),
  Fraction_ (x.Fraction_, f, this)
{
}

TransSpeedRelativeType::
TransSpeedRelativeType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::TransSpeedType (e, f | ::xml_schema::flags::base, c),
  Fraction_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void TransSpeedRelativeType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::TransSpeedType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Fraction
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Fraction",
          "",
          &::xsd::cxx::tree::factory_impl< Fraction_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Fraction_.present ())
        {
          ::std::auto_ptr< Fraction_type > r (
            dynamic_cast< Fraction_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Fraction_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Fraction_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Fraction",
      "");
  }
}

TransSpeedRelativeType* TransSpeedRelativeType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TransSpeedRelativeType (*this, f, c);
}

TransSpeedRelativeType& TransSpeedRelativeType::
operator= (const TransSpeedRelativeType& x)
{
  if (this != &x)
  {
    static_cast< ::TransSpeedType& > (*this) = x;
    this->Fraction_ = x.Fraction_;
  }

  return *this;
}

TransSpeedRelativeType::
~TransSpeedRelativeType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, TransSpeedRelativeType >
_xsd_TransSpeedRelativeType_type_factory_init (
  "TransSpeedRelativeType",
  "");

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

void
operator<< (::xercesc::DOMElement& e, const AngleUnitEnumType& i)
{
  e << static_cast< const ::xml_schema::nmtoken& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const AngleUnitEnumType& i)
{
  a << static_cast< const ::xml_schema::nmtoken& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const AngleUnitEnumType& i)
{
  l << static_cast< const ::xml_schema::nmtoken& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, AngleUnitEnumType >
_xsd_AngleUnitEnumType_type_serializer_init (
  "AngleUnitEnumType",
  "");


void
operator<< (::xercesc::DOMElement& e, const DataThingType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Name
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Name ())
    {
      const DataThingType::Name_type& x (*i.Name ());
      if (typeid (DataThingType::Name_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Name",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Name",
          "",
          false, true, e, x);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, DataThingType >
_xsd_DataThingType_type_serializer_init (
  "DataThingType",
  "");


void
operator<< (::xercesc::DOMElement& e, const ForceUnitEnumType& i)
{
  e << static_cast< const ::xml_schema::nmtoken& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const ForceUnitEnumType& i)
{
  a << static_cast< const ::xml_schema::nmtoken& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const ForceUnitEnumType& i)
{
  l << static_cast< const ::xml_schema::nmtoken& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ForceUnitEnumType >
_xsd_ForceUnitEnumType_type_serializer_init (
  "ForceUnitEnumType",
  "");


void
operator<< (::xercesc::DOMElement& e, const FractionType& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const FractionType& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const FractionType& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, FractionType >
_xsd_FractionType_type_serializer_init (
  "FractionType",
  "");


void
operator<< (::xercesc::DOMElement& e, const LengthUnitEnumType& i)
{
  e << static_cast< const ::xml_schema::nmtoken& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const LengthUnitEnumType& i)
{
  a << static_cast< const ::xml_schema::nmtoken& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const LengthUnitEnumType& i)
{
  l << static_cast< const ::xml_schema::nmtoken& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, LengthUnitEnumType >
_xsd_LengthUnitEnumType_type_serializer_init (
  "LengthUnitEnumType",
  "");


void
operator<< (::xercesc::DOMElement& e, const PointType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // X
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "X",
        e));

    s << ::xml_schema::as_double(i.X ());
  }

  // Y
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Y",
        e));

    s << ::xml_schema::as_double(i.Y ());
  }

  // Z
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Z",
        e));

    s << ::xml_schema::as_double(i.Z ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PointType >
_xsd_PointType_type_serializer_init (
  "PointType",
  "");


void
operator<< (::xercesc::DOMElement& e, const PoseType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // Point
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const PoseType::Point_type& x (i.Point ());
    if (typeid (PoseType::Point_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Point",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Point",
        "",
        false, true, e, x);
  }

  // XAxis
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const PoseType::XAxis_type& x (i.XAxis ());
    if (typeid (PoseType::XAxis_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "XAxis",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "XAxis",
        "",
        false, true, e, x);
  }

  // ZAxis
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const PoseType::ZAxis_type& x (i.ZAxis ());
    if (typeid (PoseType::ZAxis_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ZAxis",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "ZAxis",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PoseType >
_xsd_PoseType_type_serializer_init (
  "PoseType",
  "");


void
operator<< (::xercesc::DOMElement& e, const PositiveDecimalType& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const PositiveDecimalType& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const PositiveDecimalType& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PositiveDecimalType >
_xsd_PositiveDecimalType_type_serializer_init (
  "PositiveDecimalType",
  "");


void
operator<< (::xercesc::DOMElement& e, const TorqueUnitEnumType& i)
{
  e << static_cast< const ::xml_schema::nmtoken& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const TorqueUnitEnumType& i)
{
  a << static_cast< const ::xml_schema::nmtoken& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const TorqueUnitEnumType& i)
{
  l << static_cast< const ::xml_schema::nmtoken& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TorqueUnitEnumType >
_xsd_TorqueUnitEnumType_type_serializer_init (
  "TorqueUnitEnumType",
  "");


void
operator<< (::xercesc::DOMElement& e, const TwistType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // LinearVelocity
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const TwistType::LinearVelocity_type& x (i.LinearVelocity ());
    if (typeid (TwistType::LinearVelocity_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "LinearVelocity",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "LinearVelocity",
        "",
        false, true, e, x);
  }

  // AngularVelocity
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const TwistType::AngularVelocity_type& x (i.AngularVelocity ());
    if (typeid (TwistType::AngularVelocity_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "AngularVelocity",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "AngularVelocity",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TwistType >
_xsd_TwistType_type_serializer_init (
  "TwistType",
  "");


void
operator<< (::xercesc::DOMElement& e, const VectorType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // I
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "I",
        e));

    s << ::xml_schema::as_double(i.I ());
  }

  // J
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "J",
        e));

    s << ::xml_schema::as_double(i.J ());
  }

  // K
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "K",
        e));

    s << ::xml_schema::as_double(i.K ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, VectorType >
_xsd_VectorType_type_serializer_init (
  "VectorType",
  "");


void
operator<< (::xercesc::DOMElement& e, const WrenchType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // Force
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const WrenchType::Force_type& x (i.Force ());
    if (typeid (WrenchType::Force_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Force",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Force",
        "",
        false, true, e, x);
  }

  // Moment
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const WrenchType::Moment_type& x (i.Moment ());
    if (typeid (WrenchType::Moment_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Moment",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Moment",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, WrenchType >
_xsd_WrenchType_type_serializer_init (
  "WrenchType",
  "");


void
operator<< (::xercesc::DOMElement& e, const PoseToleranceType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // XPointTolerance
  //
  if (i.XPointTolerance ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "XPointTolerance",
        e));

    s << ::xml_schema::as_double(*i.XPointTolerance ());
  }

  // YPointTolerance
  //
  if (i.YPointTolerance ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "YPointTolerance",
        e));

    s << ::xml_schema::as_double(*i.YPointTolerance ());
  }

  // ZPointTolerance
  //
  if (i.ZPointTolerance ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ZPointTolerance",
        e));

    s << ::xml_schema::as_double(*i.ZPointTolerance ());
  }

  // XAxisTolerance
  //
  if (i.XAxisTolerance ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "XAxisTolerance",
        e));

    s << ::xml_schema::as_double(*i.XAxisTolerance ());
  }

  // ZAxisTolerance
  //
  if (i.ZAxisTolerance ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ZAxisTolerance",
        e));

    s << ::xml_schema::as_double(*i.ZAxisTolerance ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PoseToleranceType >
_xsd_PoseToleranceType_type_serializer_init (
  "PoseToleranceType",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParameterSettingType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // ParameterName
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const ParameterSettingType::ParameterName_type& x (i.ParameterName ());
    if (typeid (ParameterSettingType::ParameterName_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ParameterName",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "ParameterName",
        "",
        false, true, e, x);
  }

  // ParameterValue
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const ParameterSettingType::ParameterValue_type& x (i.ParameterValue ());
    if (typeid (ParameterSettingType::ParameterValue_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "ParameterValue",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "ParameterValue",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParameterSettingType >
_xsd_ParameterSettingType_type_serializer_init (
  "ParameterSettingType",
  "");


void
operator<< (::xercesc::DOMElement& e, const RotAccelType& i)
{
  e << static_cast< const ::DataThingType& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RotAccelType >
_xsd_RotAccelType_type_serializer_init (
  "RotAccelType",
  "");


void
operator<< (::xercesc::DOMElement& e, const RotAccelAbsoluteType& i)
{
  e << static_cast< const ::RotAccelType& > (i);

  // Setting
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Setting",
        e));

    s << ::xml_schema::as_double(i.Setting ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RotAccelAbsoluteType >
_xsd_RotAccelAbsoluteType_type_serializer_init (
  "RotAccelAbsoluteType",
  "");


void
operator<< (::xercesc::DOMElement& e, const RotAccelRelativeType& i)
{
  e << static_cast< const ::RotAccelType& > (i);

  // Fraction
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const RotAccelRelativeType::Fraction_type& x (i.Fraction ());
    if (typeid (RotAccelRelativeType::Fraction_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Fraction",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Fraction",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RotAccelRelativeType >
_xsd_RotAccelRelativeType_type_serializer_init (
  "RotAccelRelativeType",
  "");


void
operator<< (::xercesc::DOMElement& e, const RotSpeedType& i)
{
  e << static_cast< const ::DataThingType& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RotSpeedType >
_xsd_RotSpeedType_type_serializer_init (
  "RotSpeedType",
  "");


void
operator<< (::xercesc::DOMElement& e, const RotSpeedAbsoluteType& i)
{
  e << static_cast< const ::RotSpeedType& > (i);

  // Setting
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Setting",
        e));

    s << ::xml_schema::as_double(i.Setting ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RotSpeedAbsoluteType >
_xsd_RotSpeedAbsoluteType_type_serializer_init (
  "RotSpeedAbsoluteType",
  "");


void
operator<< (::xercesc::DOMElement& e, const RotSpeedRelativeType& i)
{
  e << static_cast< const ::RotSpeedType& > (i);

  // Fraction
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const RotSpeedRelativeType::Fraction_type& x (i.Fraction ());
    if (typeid (RotSpeedRelativeType::Fraction_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Fraction",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Fraction",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, RotSpeedRelativeType >
_xsd_RotSpeedRelativeType_type_serializer_init (
  "RotSpeedRelativeType",
  "");


void
operator<< (::xercesc::DOMElement& e, const TransAccelType& i)
{
  e << static_cast< const ::DataThingType& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TransAccelType >
_xsd_TransAccelType_type_serializer_init (
  "TransAccelType",
  "");


void
operator<< (::xercesc::DOMElement& e, const TransAccelAbsoluteType& i)
{
  e << static_cast< const ::TransAccelType& > (i);

  // Setting
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Setting",
        e));

    s << ::xml_schema::as_double(i.Setting ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TransAccelAbsoluteType >
_xsd_TransAccelAbsoluteType_type_serializer_init (
  "TransAccelAbsoluteType",
  "");


void
operator<< (::xercesc::DOMElement& e, const TransAccelRelativeType& i)
{
  e << static_cast< const ::TransAccelType& > (i);

  // Fraction
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const TransAccelRelativeType::Fraction_type& x (i.Fraction ());
    if (typeid (TransAccelRelativeType::Fraction_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Fraction",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Fraction",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TransAccelRelativeType >
_xsd_TransAccelRelativeType_type_serializer_init (
  "TransAccelRelativeType",
  "");


void
operator<< (::xercesc::DOMElement& e, const TransSpeedType& i)
{
  e << static_cast< const ::DataThingType& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TransSpeedType >
_xsd_TransSpeedType_type_serializer_init (
  "TransSpeedType",
  "");


void
operator<< (::xercesc::DOMElement& e, const TransSpeedAbsoluteType& i)
{
  e << static_cast< const ::TransSpeedType& > (i);

  // Setting
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Setting",
        e));

    s << ::xml_schema::as_double(i.Setting ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TransSpeedAbsoluteType >
_xsd_TransSpeedAbsoluteType_type_serializer_init (
  "TransSpeedAbsoluteType",
  "");


void
operator<< (::xercesc::DOMElement& e, const TransSpeedRelativeType& i)
{
  e << static_cast< const ::TransSpeedType& > (i);

  // Fraction
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const TransSpeedRelativeType::Fraction_type& x (i.Fraction ());
    if (typeid (TransSpeedRelativeType::Fraction_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Fraction",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Fraction",
        "",
        false, true, e, x);
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, TransSpeedRelativeType >
_xsd_TransSpeedRelativeType_type_serializer_init (
  "TransSpeedRelativeType",
  "");


#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

