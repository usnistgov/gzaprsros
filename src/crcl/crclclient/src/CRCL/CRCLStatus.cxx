// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "CRCLStatus.hxx"

// CommandStateEnumType
// 

CommandStateEnumType::
CommandStateEnumType (value v)
: ::xml_schema::string (_xsd_CommandStateEnumType_literals_[v])
{
}

CommandStateEnumType::
CommandStateEnumType (const char* v)
: ::xml_schema::string (v)
{
}

CommandStateEnumType::
CommandStateEnumType (const ::std::string& v)
: ::xml_schema::string (v)
{
}

CommandStateEnumType::
CommandStateEnumType (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

CommandStateEnumType::
CommandStateEnumType (const CommandStateEnumType& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

CommandStateEnumType& CommandStateEnumType::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_CommandStateEnumType_literals_[v]);

  return *this;
}


// CommandStatusType
// 

const CommandStatusType::CommandID_type& CommandStatusType::
CommandID () const
{
  return this->CommandID_.get ();
}

CommandStatusType::CommandID_type& CommandStatusType::
CommandID ()
{
  return this->CommandID_.get ();
}

void CommandStatusType::
CommandID (const CommandID_type& x)
{
  this->CommandID_.set (x);
}

const CommandStatusType::StatusID_type& CommandStatusType::
StatusID () const
{
  return this->StatusID_.get ();
}

CommandStatusType::StatusID_type& CommandStatusType::
StatusID ()
{
  return this->StatusID_.get ();
}

void CommandStatusType::
StatusID (const StatusID_type& x)
{
  this->StatusID_.set (x);
}

const CommandStatusType::CommandState_type& CommandStatusType::
CommandState () const
{
  return this->CommandState_.get ();
}

CommandStatusType::CommandState_type& CommandStatusType::
CommandState ()
{
  return this->CommandState_.get ();
}

void CommandStatusType::
CommandState (const CommandState_type& x)
{
  this->CommandState_.set (x);
}

void CommandStatusType::
CommandState (::std::auto_ptr< CommandState_type > x)
{
  this->CommandState_.set (x);
}

const CommandStatusType::StateDescription_optional& CommandStatusType::
StateDescription () const
{
  return this->StateDescription_;
}

CommandStatusType::StateDescription_optional& CommandStatusType::
StateDescription ()
{
  return this->StateDescription_;
}

void CommandStatusType::
StateDescription (const StateDescription_type& x)
{
  this->StateDescription_.set (x);
}

void CommandStatusType::
StateDescription (const StateDescription_optional& x)
{
  this->StateDescription_ = x;
}

void CommandStatusType::
StateDescription (::std::auto_ptr< StateDescription_type > x)
{
  this->StateDescription_.set (x);
}

const CommandStatusType::ProgramFile_optional& CommandStatusType::
ProgramFile () const
{
  return this->ProgramFile_;
}

CommandStatusType::ProgramFile_optional& CommandStatusType::
ProgramFile ()
{
  return this->ProgramFile_;
}

void CommandStatusType::
ProgramFile (const ProgramFile_type& x)
{
  this->ProgramFile_.set (x);
}

void CommandStatusType::
ProgramFile (const ProgramFile_optional& x)
{
  this->ProgramFile_ = x;
}

void CommandStatusType::
ProgramFile (::std::auto_ptr< ProgramFile_type > x)
{
  this->ProgramFile_.set (x);
}

const CommandStatusType::ProgramIndex_optional& CommandStatusType::
ProgramIndex () const
{
  return this->ProgramIndex_;
}

CommandStatusType::ProgramIndex_optional& CommandStatusType::
ProgramIndex ()
{
  return this->ProgramIndex_;
}

void CommandStatusType::
ProgramIndex (const ProgramIndex_type& x)
{
  this->ProgramIndex_.set (x);
}

void CommandStatusType::
ProgramIndex (const ProgramIndex_optional& x)
{
  this->ProgramIndex_ = x;
}

const CommandStatusType::ProgramLength_optional& CommandStatusType::
ProgramLength () const
{
  return this->ProgramLength_;
}

CommandStatusType::ProgramLength_optional& CommandStatusType::
ProgramLength ()
{
  return this->ProgramLength_;
}

void CommandStatusType::
ProgramLength (const ProgramLength_type& x)
{
  this->ProgramLength_.set (x);
}

void CommandStatusType::
ProgramLength (const ProgramLength_optional& x)
{
  this->ProgramLength_ = x;
}


// CRCLStatusType
// 

const CRCLStatusType::CommandStatus_type& CRCLStatusType::
CommandStatus () const
{
  return this->CommandStatus_.get ();
}

CRCLStatusType::CommandStatus_type& CRCLStatusType::
CommandStatus ()
{
  return this->CommandStatus_.get ();
}

void CRCLStatusType::
CommandStatus (const CommandStatus_type& x)
{
  this->CommandStatus_.set (x);
}

void CRCLStatusType::
CommandStatus (::std::auto_ptr< CommandStatus_type > x)
{
  this->CommandStatus_.set (x);
}

const CRCLStatusType::JointStatuses_optional& CRCLStatusType::
JointStatuses () const
{
  return this->JointStatuses_;
}

CRCLStatusType::JointStatuses_optional& CRCLStatusType::
JointStatuses ()
{
  return this->JointStatuses_;
}

void CRCLStatusType::
JointStatuses (const JointStatuses_type& x)
{
  this->JointStatuses_.set (x);
}

void CRCLStatusType::
JointStatuses (const JointStatuses_optional& x)
{
  this->JointStatuses_ = x;
}

void CRCLStatusType::
JointStatuses (::std::auto_ptr< JointStatuses_type > x)
{
  this->JointStatuses_.set (x);
}

const CRCLStatusType::PoseStatus_optional& CRCLStatusType::
PoseStatus () const
{
  return this->PoseStatus_;
}

CRCLStatusType::PoseStatus_optional& CRCLStatusType::
PoseStatus ()
{
  return this->PoseStatus_;
}

void CRCLStatusType::
PoseStatus (const PoseStatus_type& x)
{
  this->PoseStatus_.set (x);
}

void CRCLStatusType::
PoseStatus (const PoseStatus_optional& x)
{
  this->PoseStatus_ = x;
}

void CRCLStatusType::
PoseStatus (::std::auto_ptr< PoseStatus_type > x)
{
  this->PoseStatus_.set (x);
}

const CRCLStatusType::GripperStatus_optional& CRCLStatusType::
GripperStatus () const
{
  return this->GripperStatus_;
}

CRCLStatusType::GripperStatus_optional& CRCLStatusType::
GripperStatus ()
{
  return this->GripperStatus_;
}

void CRCLStatusType::
GripperStatus (const GripperStatus_type& x)
{
  this->GripperStatus_.set (x);
}

void CRCLStatusType::
GripperStatus (const GripperStatus_optional& x)
{
  this->GripperStatus_ = x;
}

void CRCLStatusType::
GripperStatus (::std::auto_ptr< GripperStatus_type > x)
{
  this->GripperStatus_.set (x);
}

const CRCLStatusType::SettingsStatus_optional& CRCLStatusType::
SettingsStatus () const
{
  return this->SettingsStatus_;
}

CRCLStatusType::SettingsStatus_optional& CRCLStatusType::
SettingsStatus ()
{
  return this->SettingsStatus_;
}

void CRCLStatusType::
SettingsStatus (const SettingsStatus_type& x)
{
  this->SettingsStatus_.set (x);
}

void CRCLStatusType::
SettingsStatus (const SettingsStatus_optional& x)
{
  this->SettingsStatus_ = x;
}

void CRCLStatusType::
SettingsStatus (::std::auto_ptr< SettingsStatus_type > x)
{
  this->SettingsStatus_.set (x);
}


// GripperStatusType
// 

const GripperStatusType::GripperName_type& GripperStatusType::
GripperName () const
{
  return this->GripperName_.get ();
}

GripperStatusType::GripperName_type& GripperStatusType::
GripperName ()
{
  return this->GripperName_.get ();
}

void GripperStatusType::
GripperName (const GripperName_type& x)
{
  this->GripperName_.set (x);
}

void GripperStatusType::
GripperName (::std::auto_ptr< GripperName_type > x)
{
  this->GripperName_.set (x);
}

const GripperStatusType::HoldingObject_optional& GripperStatusType::
HoldingObject () const
{
  return this->HoldingObject_;
}

GripperStatusType::HoldingObject_optional& GripperStatusType::
HoldingObject ()
{
  return this->HoldingObject_;
}

void GripperStatusType::
HoldingObject (const HoldingObject_type& x)
{
  this->HoldingObject_.set (x);
}

void GripperStatusType::
HoldingObject (const HoldingObject_optional& x)
{
  this->HoldingObject_ = x;
}


// JointStatusesType
// 

const JointStatusesType::JointStatus_sequence& JointStatusesType::
JointStatus () const
{
  return this->JointStatus_;
}

JointStatusesType::JointStatus_sequence& JointStatusesType::
JointStatus ()
{
  return this->JointStatus_;
}

void JointStatusesType::
JointStatus (const JointStatus_sequence& s)
{
  this->JointStatus_ = s;
}


// JointStatusType
// 

const JointStatusType::JointNumber_type& JointStatusType::
JointNumber () const
{
  return this->JointNumber_.get ();
}

JointStatusType::JointNumber_type& JointStatusType::
JointNumber ()
{
  return this->JointNumber_.get ();
}

void JointStatusType::
JointNumber (const JointNumber_type& x)
{
  this->JointNumber_.set (x);
}

const JointStatusType::JointPosition_optional& JointStatusType::
JointPosition () const
{
  return this->JointPosition_;
}

JointStatusType::JointPosition_optional& JointStatusType::
JointPosition ()
{
  return this->JointPosition_;
}

void JointStatusType::
JointPosition (const JointPosition_type& x)
{
  this->JointPosition_.set (x);
}

void JointStatusType::
JointPosition (const JointPosition_optional& x)
{
  this->JointPosition_ = x;
}

const JointStatusType::JointTorqueOrForce_optional& JointStatusType::
JointTorqueOrForce () const
{
  return this->JointTorqueOrForce_;
}

JointStatusType::JointTorqueOrForce_optional& JointStatusType::
JointTorqueOrForce ()
{
  return this->JointTorqueOrForce_;
}

void JointStatusType::
JointTorqueOrForce (const JointTorqueOrForce_type& x)
{
  this->JointTorqueOrForce_.set (x);
}

void JointStatusType::
JointTorqueOrForce (const JointTorqueOrForce_optional& x)
{
  this->JointTorqueOrForce_ = x;
}

const JointStatusType::JointVelocity_optional& JointStatusType::
JointVelocity () const
{
  return this->JointVelocity_;
}

JointStatusType::JointVelocity_optional& JointStatusType::
JointVelocity ()
{
  return this->JointVelocity_;
}

void JointStatusType::
JointVelocity (const JointVelocity_type& x)
{
  this->JointVelocity_.set (x);
}

void JointStatusType::
JointVelocity (const JointVelocity_optional& x)
{
  this->JointVelocity_ = x;
}


// JointLimitType
// 

const JointLimitType::JointNumber_type& JointLimitType::
JointNumber () const
{
  return this->JointNumber_.get ();
}

JointLimitType::JointNumber_type& JointLimitType::
JointNumber ()
{
  return this->JointNumber_.get ();
}

void JointLimitType::
JointNumber (const JointNumber_type& x)
{
  this->JointNumber_.set (x);
}

const JointLimitType::JointMinPosition_optional& JointLimitType::
JointMinPosition () const
{
  return this->JointMinPosition_;
}

JointLimitType::JointMinPosition_optional& JointLimitType::
JointMinPosition ()
{
  return this->JointMinPosition_;
}

void JointLimitType::
JointMinPosition (const JointMinPosition_type& x)
{
  this->JointMinPosition_.set (x);
}

void JointLimitType::
JointMinPosition (const JointMinPosition_optional& x)
{
  this->JointMinPosition_ = x;
}

const JointLimitType::JointMaxPosition_optional& JointLimitType::
JointMaxPosition () const
{
  return this->JointMaxPosition_;
}

JointLimitType::JointMaxPosition_optional& JointLimitType::
JointMaxPosition ()
{
  return this->JointMaxPosition_;
}

void JointLimitType::
JointMaxPosition (const JointMaxPosition_type& x)
{
  this->JointMaxPosition_.set (x);
}

void JointLimitType::
JointMaxPosition (const JointMaxPosition_optional& x)
{
  this->JointMaxPosition_ = x;
}

const JointLimitType::JointMaxTorqueOrForce_optional& JointLimitType::
JointMaxTorqueOrForce () const
{
  return this->JointMaxTorqueOrForce_;
}

JointLimitType::JointMaxTorqueOrForce_optional& JointLimitType::
JointMaxTorqueOrForce ()
{
  return this->JointMaxTorqueOrForce_;
}

void JointLimitType::
JointMaxTorqueOrForce (const JointMaxTorqueOrForce_type& x)
{
  this->JointMaxTorqueOrForce_.set (x);
}

void JointLimitType::
JointMaxTorqueOrForce (const JointMaxTorqueOrForce_optional& x)
{
  this->JointMaxTorqueOrForce_ = x;
}

const JointLimitType::JointMaxVelocity_optional& JointLimitType::
JointMaxVelocity () const
{
  return this->JointMaxVelocity_;
}

JointLimitType::JointMaxVelocity_optional& JointLimitType::
JointMaxVelocity ()
{
  return this->JointMaxVelocity_;
}

void JointLimitType::
JointMaxVelocity (const JointMaxVelocity_type& x)
{
  this->JointMaxVelocity_.set (x);
}

void JointLimitType::
JointMaxVelocity (const JointMaxVelocity_optional& x)
{
  this->JointMaxVelocity_ = x;
}


// ParallelGripperStatusType
// 

const ParallelGripperStatusType::Separation_type& ParallelGripperStatusType::
Separation () const
{
  return this->Separation_.get ();
}

ParallelGripperStatusType::Separation_type& ParallelGripperStatusType::
Separation ()
{
  return this->Separation_.get ();
}

void ParallelGripperStatusType::
Separation (const Separation_type& x)
{
  this->Separation_.set (x);
}


// PoseStatusType
// 

const PoseStatusType::Pose_type& PoseStatusType::
Pose () const
{
  return this->Pose_.get ();
}

PoseStatusType::Pose_type& PoseStatusType::
Pose ()
{
  return this->Pose_.get ();
}

void PoseStatusType::
Pose (const Pose_type& x)
{
  this->Pose_.set (x);
}

void PoseStatusType::
Pose (::std::auto_ptr< Pose_type > x)
{
  this->Pose_.set (x);
}

const PoseStatusType::Twist_optional& PoseStatusType::
Twist () const
{
  return this->Twist_;
}

PoseStatusType::Twist_optional& PoseStatusType::
Twist ()
{
  return this->Twist_;
}

void PoseStatusType::
Twist (const Twist_type& x)
{
  this->Twist_.set (x);
}

void PoseStatusType::
Twist (const Twist_optional& x)
{
  this->Twist_ = x;
}

void PoseStatusType::
Twist (::std::auto_ptr< Twist_type > x)
{
  this->Twist_.set (x);
}

const PoseStatusType::Wrench_optional& PoseStatusType::
Wrench () const
{
  return this->Wrench_;
}

PoseStatusType::Wrench_optional& PoseStatusType::
Wrench ()
{
  return this->Wrench_;
}

void PoseStatusType::
Wrench (const Wrench_type& x)
{
  this->Wrench_.set (x);
}

void PoseStatusType::
Wrench (const Wrench_optional& x)
{
  this->Wrench_ = x;
}

void PoseStatusType::
Wrench (::std::auto_ptr< Wrench_type > x)
{
  this->Wrench_.set (x);
}

const PoseStatusType::Configuration_optional& PoseStatusType::
Configuration () const
{
  return this->Configuration_;
}

PoseStatusType::Configuration_optional& PoseStatusType::
Configuration ()
{
  return this->Configuration_;
}

void PoseStatusType::
Configuration (const Configuration_type& x)
{
  this->Configuration_.set (x);
}

void PoseStatusType::
Configuration (const Configuration_optional& x)
{
  this->Configuration_ = x;
}

void PoseStatusType::
Configuration (::std::auto_ptr< Configuration_type > x)
{
  this->Configuration_.set (x);
}


// SettingsStatusType
// 

const SettingsStatusType::AngleUnitName_optional& SettingsStatusType::
AngleUnitName () const
{
  return this->AngleUnitName_;
}

SettingsStatusType::AngleUnitName_optional& SettingsStatusType::
AngleUnitName ()
{
  return this->AngleUnitName_;
}

void SettingsStatusType::
AngleUnitName (const AngleUnitName_type& x)
{
  this->AngleUnitName_.set (x);
}

void SettingsStatusType::
AngleUnitName (const AngleUnitName_optional& x)
{
  this->AngleUnitName_ = x;
}

void SettingsStatusType::
AngleUnitName (::std::auto_ptr< AngleUnitName_type > x)
{
  this->AngleUnitName_.set (x);
}

const SettingsStatusType::EndEffectorParameterSetting_sequence& SettingsStatusType::
EndEffectorParameterSetting () const
{
  return this->EndEffectorParameterSetting_;
}

SettingsStatusType::EndEffectorParameterSetting_sequence& SettingsStatusType::
EndEffectorParameterSetting ()
{
  return this->EndEffectorParameterSetting_;
}

void SettingsStatusType::
EndEffectorParameterSetting (const EndEffectorParameterSetting_sequence& s)
{
  this->EndEffectorParameterSetting_ = s;
}

const SettingsStatusType::EndEffectorSetting_optional& SettingsStatusType::
EndEffectorSetting () const
{
  return this->EndEffectorSetting_;
}

SettingsStatusType::EndEffectorSetting_optional& SettingsStatusType::
EndEffectorSetting ()
{
  return this->EndEffectorSetting_;
}

void SettingsStatusType::
EndEffectorSetting (const EndEffectorSetting_type& x)
{
  this->EndEffectorSetting_.set (x);
}

void SettingsStatusType::
EndEffectorSetting (const EndEffectorSetting_optional& x)
{
  this->EndEffectorSetting_ = x;
}

void SettingsStatusType::
EndEffectorSetting (::std::auto_ptr< EndEffectorSetting_type > x)
{
  this->EndEffectorSetting_.set (x);
}

const SettingsStatusType::ForceUnitName_optional& SettingsStatusType::
ForceUnitName () const
{
  return this->ForceUnitName_;
}

SettingsStatusType::ForceUnitName_optional& SettingsStatusType::
ForceUnitName ()
{
  return this->ForceUnitName_;
}

void SettingsStatusType::
ForceUnitName (const ForceUnitName_type& x)
{
  this->ForceUnitName_.set (x);
}

void SettingsStatusType::
ForceUnitName (const ForceUnitName_optional& x)
{
  this->ForceUnitName_ = x;
}

void SettingsStatusType::
ForceUnitName (::std::auto_ptr< ForceUnitName_type > x)
{
  this->ForceUnitName_.set (x);
}

const SettingsStatusType::JointLimits_sequence& SettingsStatusType::
JointLimits () const
{
  return this->JointLimits_;
}

SettingsStatusType::JointLimits_sequence& SettingsStatusType::
JointLimits ()
{
  return this->JointLimits_;
}

void SettingsStatusType::
JointLimits (const JointLimits_sequence& s)
{
  this->JointLimits_ = s;
}

const SettingsStatusType::IntermediatePoseTolerance_optional& SettingsStatusType::
IntermediatePoseTolerance () const
{
  return this->IntermediatePoseTolerance_;
}

SettingsStatusType::IntermediatePoseTolerance_optional& SettingsStatusType::
IntermediatePoseTolerance ()
{
  return this->IntermediatePoseTolerance_;
}

void SettingsStatusType::
IntermediatePoseTolerance (const IntermediatePoseTolerance_type& x)
{
  this->IntermediatePoseTolerance_.set (x);
}

void SettingsStatusType::
IntermediatePoseTolerance (const IntermediatePoseTolerance_optional& x)
{
  this->IntermediatePoseTolerance_ = x;
}

void SettingsStatusType::
IntermediatePoseTolerance (::std::auto_ptr< IntermediatePoseTolerance_type > x)
{
  this->IntermediatePoseTolerance_.set (x);
}

const SettingsStatusType::LengthUnitName_optional& SettingsStatusType::
LengthUnitName () const
{
  return this->LengthUnitName_;
}

SettingsStatusType::LengthUnitName_optional& SettingsStatusType::
LengthUnitName ()
{
  return this->LengthUnitName_;
}

void SettingsStatusType::
LengthUnitName (const LengthUnitName_type& x)
{
  this->LengthUnitName_.set (x);
}

void SettingsStatusType::
LengthUnitName (const LengthUnitName_optional& x)
{
  this->LengthUnitName_ = x;
}

void SettingsStatusType::
LengthUnitName (::std::auto_ptr< LengthUnitName_type > x)
{
  this->LengthUnitName_.set (x);
}

const SettingsStatusType::MaxCartesianLimit_optional& SettingsStatusType::
MaxCartesianLimit () const
{
  return this->MaxCartesianLimit_;
}

SettingsStatusType::MaxCartesianLimit_optional& SettingsStatusType::
MaxCartesianLimit ()
{
  return this->MaxCartesianLimit_;
}

void SettingsStatusType::
MaxCartesianLimit (const MaxCartesianLimit_type& x)
{
  this->MaxCartesianLimit_.set (x);
}

void SettingsStatusType::
MaxCartesianLimit (const MaxCartesianLimit_optional& x)
{
  this->MaxCartesianLimit_ = x;
}

void SettingsStatusType::
MaxCartesianLimit (::std::auto_ptr< MaxCartesianLimit_type > x)
{
  this->MaxCartesianLimit_.set (x);
}

const SettingsStatusType::MinCartesianLimit_optional& SettingsStatusType::
MinCartesianLimit () const
{
  return this->MinCartesianLimit_;
}

SettingsStatusType::MinCartesianLimit_optional& SettingsStatusType::
MinCartesianLimit ()
{
  return this->MinCartesianLimit_;
}

void SettingsStatusType::
MinCartesianLimit (const MinCartesianLimit_type& x)
{
  this->MinCartesianLimit_.set (x);
}

void SettingsStatusType::
MinCartesianLimit (const MinCartesianLimit_optional& x)
{
  this->MinCartesianLimit_ = x;
}

void SettingsStatusType::
MinCartesianLimit (::std::auto_ptr< MinCartesianLimit_type > x)
{
  this->MinCartesianLimit_.set (x);
}

const SettingsStatusType::MotionCoordinated_optional& SettingsStatusType::
MotionCoordinated () const
{
  return this->MotionCoordinated_;
}

SettingsStatusType::MotionCoordinated_optional& SettingsStatusType::
MotionCoordinated ()
{
  return this->MotionCoordinated_;
}

void SettingsStatusType::
MotionCoordinated (const MotionCoordinated_type& x)
{
  this->MotionCoordinated_.set (x);
}

void SettingsStatusType::
MotionCoordinated (const MotionCoordinated_optional& x)
{
  this->MotionCoordinated_ = x;
}

const SettingsStatusType::PoseTolerance_optional& SettingsStatusType::
PoseTolerance () const
{
  return this->PoseTolerance_;
}

SettingsStatusType::PoseTolerance_optional& SettingsStatusType::
PoseTolerance ()
{
  return this->PoseTolerance_;
}

void SettingsStatusType::
PoseTolerance (const PoseTolerance_type& x)
{
  this->PoseTolerance_.set (x);
}

void SettingsStatusType::
PoseTolerance (const PoseTolerance_optional& x)
{
  this->PoseTolerance_ = x;
}

void SettingsStatusType::
PoseTolerance (::std::auto_ptr< PoseTolerance_type > x)
{
  this->PoseTolerance_.set (x);
}

const SettingsStatusType::RobotParameterSetting_sequence& SettingsStatusType::
RobotParameterSetting () const
{
  return this->RobotParameterSetting_;
}

SettingsStatusType::RobotParameterSetting_sequence& SettingsStatusType::
RobotParameterSetting ()
{
  return this->RobotParameterSetting_;
}

void SettingsStatusType::
RobotParameterSetting (const RobotParameterSetting_sequence& s)
{
  this->RobotParameterSetting_ = s;
}

const SettingsStatusType::RotAccelAbsolute_optional& SettingsStatusType::
RotAccelAbsolute () const
{
  return this->RotAccelAbsolute_;
}

SettingsStatusType::RotAccelAbsolute_optional& SettingsStatusType::
RotAccelAbsolute ()
{
  return this->RotAccelAbsolute_;
}

void SettingsStatusType::
RotAccelAbsolute (const RotAccelAbsolute_type& x)
{
  this->RotAccelAbsolute_.set (x);
}

void SettingsStatusType::
RotAccelAbsolute (const RotAccelAbsolute_optional& x)
{
  this->RotAccelAbsolute_ = x;
}

void SettingsStatusType::
RotAccelAbsolute (::std::auto_ptr< RotAccelAbsolute_type > x)
{
  this->RotAccelAbsolute_.set (x);
}

const SettingsStatusType::RotAccelRelative_optional& SettingsStatusType::
RotAccelRelative () const
{
  return this->RotAccelRelative_;
}

SettingsStatusType::RotAccelRelative_optional& SettingsStatusType::
RotAccelRelative ()
{
  return this->RotAccelRelative_;
}

void SettingsStatusType::
RotAccelRelative (const RotAccelRelative_type& x)
{
  this->RotAccelRelative_.set (x);
}

void SettingsStatusType::
RotAccelRelative (const RotAccelRelative_optional& x)
{
  this->RotAccelRelative_ = x;
}

void SettingsStatusType::
RotAccelRelative (::std::auto_ptr< RotAccelRelative_type > x)
{
  this->RotAccelRelative_.set (x);
}

const SettingsStatusType::RotSpeedAbsolute_optional& SettingsStatusType::
RotSpeedAbsolute () const
{
  return this->RotSpeedAbsolute_;
}

SettingsStatusType::RotSpeedAbsolute_optional& SettingsStatusType::
RotSpeedAbsolute ()
{
  return this->RotSpeedAbsolute_;
}

void SettingsStatusType::
RotSpeedAbsolute (const RotSpeedAbsolute_type& x)
{
  this->RotSpeedAbsolute_.set (x);
}

void SettingsStatusType::
RotSpeedAbsolute (const RotSpeedAbsolute_optional& x)
{
  this->RotSpeedAbsolute_ = x;
}

void SettingsStatusType::
RotSpeedAbsolute (::std::auto_ptr< RotSpeedAbsolute_type > x)
{
  this->RotSpeedAbsolute_.set (x);
}

const SettingsStatusType::RotSpeedRelative_optional& SettingsStatusType::
RotSpeedRelative () const
{
  return this->RotSpeedRelative_;
}

SettingsStatusType::RotSpeedRelative_optional& SettingsStatusType::
RotSpeedRelative ()
{
  return this->RotSpeedRelative_;
}

void SettingsStatusType::
RotSpeedRelative (const RotSpeedRelative_type& x)
{
  this->RotSpeedRelative_.set (x);
}

void SettingsStatusType::
RotSpeedRelative (const RotSpeedRelative_optional& x)
{
  this->RotSpeedRelative_ = x;
}

void SettingsStatusType::
RotSpeedRelative (::std::auto_ptr< RotSpeedRelative_type > x)
{
  this->RotSpeedRelative_.set (x);
}

const SettingsStatusType::TorqueUnitName_optional& SettingsStatusType::
TorqueUnitName () const
{
  return this->TorqueUnitName_;
}

SettingsStatusType::TorqueUnitName_optional& SettingsStatusType::
TorqueUnitName ()
{
  return this->TorqueUnitName_;
}

void SettingsStatusType::
TorqueUnitName (const TorqueUnitName_type& x)
{
  this->TorqueUnitName_.set (x);
}

void SettingsStatusType::
TorqueUnitName (const TorqueUnitName_optional& x)
{
  this->TorqueUnitName_ = x;
}

void SettingsStatusType::
TorqueUnitName (::std::auto_ptr< TorqueUnitName_type > x)
{
  this->TorqueUnitName_.set (x);
}

const SettingsStatusType::TransAccelAbsolute_optional& SettingsStatusType::
TransAccelAbsolute () const
{
  return this->TransAccelAbsolute_;
}

SettingsStatusType::TransAccelAbsolute_optional& SettingsStatusType::
TransAccelAbsolute ()
{
  return this->TransAccelAbsolute_;
}

void SettingsStatusType::
TransAccelAbsolute (const TransAccelAbsolute_type& x)
{
  this->TransAccelAbsolute_.set (x);
}

void SettingsStatusType::
TransAccelAbsolute (const TransAccelAbsolute_optional& x)
{
  this->TransAccelAbsolute_ = x;
}

void SettingsStatusType::
TransAccelAbsolute (::std::auto_ptr< TransAccelAbsolute_type > x)
{
  this->TransAccelAbsolute_.set (x);
}

const SettingsStatusType::TransAccelRelative_optional& SettingsStatusType::
TransAccelRelative () const
{
  return this->TransAccelRelative_;
}

SettingsStatusType::TransAccelRelative_optional& SettingsStatusType::
TransAccelRelative ()
{
  return this->TransAccelRelative_;
}

void SettingsStatusType::
TransAccelRelative (const TransAccelRelative_type& x)
{
  this->TransAccelRelative_.set (x);
}

void SettingsStatusType::
TransAccelRelative (const TransAccelRelative_optional& x)
{
  this->TransAccelRelative_ = x;
}

void SettingsStatusType::
TransAccelRelative (::std::auto_ptr< TransAccelRelative_type > x)
{
  this->TransAccelRelative_.set (x);
}

const SettingsStatusType::TransSpeedAbsolute_optional& SettingsStatusType::
TransSpeedAbsolute () const
{
  return this->TransSpeedAbsolute_;
}

SettingsStatusType::TransSpeedAbsolute_optional& SettingsStatusType::
TransSpeedAbsolute ()
{
  return this->TransSpeedAbsolute_;
}

void SettingsStatusType::
TransSpeedAbsolute (const TransSpeedAbsolute_type& x)
{
  this->TransSpeedAbsolute_.set (x);
}

void SettingsStatusType::
TransSpeedAbsolute (const TransSpeedAbsolute_optional& x)
{
  this->TransSpeedAbsolute_ = x;
}

void SettingsStatusType::
TransSpeedAbsolute (::std::auto_ptr< TransSpeedAbsolute_type > x)
{
  this->TransSpeedAbsolute_.set (x);
}

const SettingsStatusType::TransSpeedRelative_optional& SettingsStatusType::
TransSpeedRelative () const
{
  return this->TransSpeedRelative_;
}

SettingsStatusType::TransSpeedRelative_optional& SettingsStatusType::
TransSpeedRelative ()
{
  return this->TransSpeedRelative_;
}

void SettingsStatusType::
TransSpeedRelative (const TransSpeedRelative_type& x)
{
  this->TransSpeedRelative_.set (x);
}

void SettingsStatusType::
TransSpeedRelative (const TransSpeedRelative_optional& x)
{
  this->TransSpeedRelative_ = x;
}

void SettingsStatusType::
TransSpeedRelative (::std::auto_ptr< TransSpeedRelative_type > x)
{
  this->TransSpeedRelative_.set (x);
}


// ThreeFingerGripperStatusType
// 

const ThreeFingerGripperStatusType::Finger1Position_optional& ThreeFingerGripperStatusType::
Finger1Position () const
{
  return this->Finger1Position_;
}

ThreeFingerGripperStatusType::Finger1Position_optional& ThreeFingerGripperStatusType::
Finger1Position ()
{
  return this->Finger1Position_;
}

void ThreeFingerGripperStatusType::
Finger1Position (const Finger1Position_type& x)
{
  this->Finger1Position_.set (x);
}

void ThreeFingerGripperStatusType::
Finger1Position (const Finger1Position_optional& x)
{
  this->Finger1Position_ = x;
}

void ThreeFingerGripperStatusType::
Finger1Position (::std::auto_ptr< Finger1Position_type > x)
{
  this->Finger1Position_.set (x);
}

const ThreeFingerGripperStatusType::Finger2Position_optional& ThreeFingerGripperStatusType::
Finger2Position () const
{
  return this->Finger2Position_;
}

ThreeFingerGripperStatusType::Finger2Position_optional& ThreeFingerGripperStatusType::
Finger2Position ()
{
  return this->Finger2Position_;
}

void ThreeFingerGripperStatusType::
Finger2Position (const Finger2Position_type& x)
{
  this->Finger2Position_.set (x);
}

void ThreeFingerGripperStatusType::
Finger2Position (const Finger2Position_optional& x)
{
  this->Finger2Position_ = x;
}

void ThreeFingerGripperStatusType::
Finger2Position (::std::auto_ptr< Finger2Position_type > x)
{
  this->Finger2Position_.set (x);
}

const ThreeFingerGripperStatusType::Finger3Position_optional& ThreeFingerGripperStatusType::
Finger3Position () const
{
  return this->Finger3Position_;
}

ThreeFingerGripperStatusType::Finger3Position_optional& ThreeFingerGripperStatusType::
Finger3Position ()
{
  return this->Finger3Position_;
}

void ThreeFingerGripperStatusType::
Finger3Position (const Finger3Position_type& x)
{
  this->Finger3Position_.set (x);
}

void ThreeFingerGripperStatusType::
Finger3Position (const Finger3Position_optional& x)
{
  this->Finger3Position_ = x;
}

void ThreeFingerGripperStatusType::
Finger3Position (::std::auto_ptr< Finger3Position_type > x)
{
  this->Finger3Position_.set (x);
}

const ThreeFingerGripperStatusType::Finger1Force_optional& ThreeFingerGripperStatusType::
Finger1Force () const
{
  return this->Finger1Force_;
}

ThreeFingerGripperStatusType::Finger1Force_optional& ThreeFingerGripperStatusType::
Finger1Force ()
{
  return this->Finger1Force_;
}

void ThreeFingerGripperStatusType::
Finger1Force (const Finger1Force_type& x)
{
  this->Finger1Force_.set (x);
}

void ThreeFingerGripperStatusType::
Finger1Force (const Finger1Force_optional& x)
{
  this->Finger1Force_ = x;
}

const ThreeFingerGripperStatusType::Finger2Force_optional& ThreeFingerGripperStatusType::
Finger2Force () const
{
  return this->Finger2Force_;
}

ThreeFingerGripperStatusType::Finger2Force_optional& ThreeFingerGripperStatusType::
Finger2Force ()
{
  return this->Finger2Force_;
}

void ThreeFingerGripperStatusType::
Finger2Force (const Finger2Force_type& x)
{
  this->Finger2Force_.set (x);
}

void ThreeFingerGripperStatusType::
Finger2Force (const Finger2Force_optional& x)
{
  this->Finger2Force_ = x;
}

const ThreeFingerGripperStatusType::Finger3Force_optional& ThreeFingerGripperStatusType::
Finger3Force () const
{
  return this->Finger3Force_;
}

ThreeFingerGripperStatusType::Finger3Force_optional& ThreeFingerGripperStatusType::
Finger3Force ()
{
  return this->Finger3Force_;
}

void ThreeFingerGripperStatusType::
Finger3Force (const Finger3Force_type& x)
{
  this->Finger3Force_.set (x);
}

void ThreeFingerGripperStatusType::
Finger3Force (const Finger3Force_optional& x)
{
  this->Finger3Force_ = x;
}


// VacuumGripperStatusType
// 

const VacuumGripperStatusType::IsPowered_type& VacuumGripperStatusType::
IsPowered () const
{
  return this->IsPowered_.get ();
}

VacuumGripperStatusType::IsPowered_type& VacuumGripperStatusType::
IsPowered ()
{
  return this->IsPowered_.get ();
}

void VacuumGripperStatusType::
IsPowered (const IsPowered_type& x)
{
  this->IsPowered_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

// CommandStateEnumType
//

CommandStateEnumType::
CommandStateEnumType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_CommandStateEnumType_convert ();
}

CommandStateEnumType::
CommandStateEnumType (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_CommandStateEnumType_convert ();
}

CommandStateEnumType::
CommandStateEnumType (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_CommandStateEnumType_convert ();
}

CommandStateEnumType* CommandStateEnumType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CommandStateEnumType (*this, f, c);
}

CommandStateEnumType::value CommandStateEnumType::
_xsd_CommandStateEnumType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_CommandStateEnumType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_CommandStateEnumType_indexes_,
                    _xsd_CommandStateEnumType_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_CommandStateEnumType_indexes_ + 4 || _xsd_CommandStateEnumType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const CommandStateEnumType::
_xsd_CommandStateEnumType_literals_[4] =
{
  "CRCL_Done",
  "CRCL_Error",
  "CRCL_Working",
  "CRCL_Ready"
};

const CommandStateEnumType::value CommandStateEnumType::
_xsd_CommandStateEnumType_indexes_[4] =
{
  ::CommandStateEnumType::CRCL_Done,
  ::CommandStateEnumType::CRCL_Error,
  ::CommandStateEnumType::CRCL_Ready,
  ::CommandStateEnumType::CRCL_Working
};

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, CommandStateEnumType >
_xsd_CommandStateEnumType_type_factory_init (
  "CommandStateEnumType",
  "");

// CommandStatusType
//

CommandStatusType::
CommandStatusType (const CommandID_type& CommandID,
                   const StatusID_type& StatusID,
                   const CommandState_type& CommandState)
: ::DataThingType (),
  CommandID_ (CommandID, this),
  StatusID_ (StatusID, this),
  CommandState_ (CommandState, this),
  StateDescription_ (this),
  ProgramFile_ (this),
  ProgramIndex_ (this),
  ProgramLength_ (this)
{
}

CommandStatusType::
CommandStatusType (const CommandID_type& CommandID,
                   const StatusID_type& StatusID,
                   ::std::auto_ptr< CommandState_type > CommandState)
: ::DataThingType (),
  CommandID_ (CommandID, this),
  StatusID_ (StatusID, this),
  CommandState_ (CommandState, this),
  StateDescription_ (this),
  ProgramFile_ (this),
  ProgramIndex_ (this),
  ProgramLength_ (this)
{
}

CommandStatusType::
CommandStatusType (const CommandStatusType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  CommandID_ (x.CommandID_, f, this),
  StatusID_ (x.StatusID_, f, this),
  CommandState_ (x.CommandState_, f, this),
  StateDescription_ (x.StateDescription_, f, this),
  ProgramFile_ (x.ProgramFile_, f, this),
  ProgramIndex_ (x.ProgramIndex_, f, this),
  ProgramLength_ (x.ProgramLength_, f, this)
{
}

CommandStatusType::
CommandStatusType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  CommandID_ (this),
  StatusID_ (this),
  CommandState_ (this),
  StateDescription_ (this),
  ProgramFile_ (this),
  ProgramIndex_ (this),
  ProgramLength_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void CommandStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // CommandID
    //
    if (n.name () == "CommandID" && n.namespace_ ().empty ())
    {
      if (!CommandID_.present ())
      {
        this->CommandID_.set (CommandID_traits::create (i, f, this));
        continue;
      }
    }

    // StatusID
    //
    if (n.name () == "StatusID" && n.namespace_ ().empty ())
    {
      if (!StatusID_.present ())
      {
        this->StatusID_.set (StatusID_traits::create (i, f, this));
        continue;
      }
    }

    // CommandState
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "CommandState",
          "",
          &::xsd::cxx::tree::factory_impl< CommandState_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!CommandState_.present ())
        {
          ::std::auto_ptr< CommandState_type > r (
            dynamic_cast< CommandState_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->CommandState_.set (r);
          continue;
        }
      }
    }

    // StateDescription
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "StateDescription",
          "",
          &::xsd::cxx::tree::factory_impl< StateDescription_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->StateDescription_)
        {
          ::std::auto_ptr< StateDescription_type > r (
            dynamic_cast< StateDescription_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->StateDescription_.set (r);
          continue;
        }
      }
    }

    // ProgramFile
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ProgramFile",
          "",
          &::xsd::cxx::tree::factory_impl< ProgramFile_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->ProgramFile_)
        {
          ::std::auto_ptr< ProgramFile_type > r (
            dynamic_cast< ProgramFile_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ProgramFile_.set (r);
          continue;
        }
      }
    }

    // ProgramIndex
    //
    if (n.name () == "ProgramIndex" && n.namespace_ ().empty ())
    {
      if (!this->ProgramIndex_)
      {
        this->ProgramIndex_.set (ProgramIndex_traits::create (i, f, this));
        continue;
      }
    }

    // ProgramLength
    //
    if (n.name () == "ProgramLength" && n.namespace_ ().empty ())
    {
      if (!this->ProgramLength_)
      {
        this->ProgramLength_.set (ProgramLength_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!CommandID_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "CommandID",
      "");
  }

  if (!StatusID_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "StatusID",
      "");
  }

  if (!CommandState_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "CommandState",
      "");
  }
}

CommandStatusType* CommandStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CommandStatusType (*this, f, c);
}

CommandStatusType& CommandStatusType::
operator= (const CommandStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->CommandID_ = x.CommandID_;
    this->StatusID_ = x.StatusID_;
    this->CommandState_ = x.CommandState_;
    this->StateDescription_ = x.StateDescription_;
    this->ProgramFile_ = x.ProgramFile_;
    this->ProgramIndex_ = x.ProgramIndex_;
    this->ProgramLength_ = x.ProgramLength_;
  }

  return *this;
}

CommandStatusType::
~CommandStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, CommandStatusType >
_xsd_CommandStatusType_type_factory_init (
  "CommandStatusType",
  "");

// CRCLStatusType
//

CRCLStatusType::
CRCLStatusType (const CommandStatus_type& CommandStatus)
: ::DataThingType (),
  CommandStatus_ (CommandStatus, this),
  JointStatuses_ (this),
  PoseStatus_ (this),
  GripperStatus_ (this),
  SettingsStatus_ (this)
{
}

CRCLStatusType::
CRCLStatusType (::std::auto_ptr< CommandStatus_type > CommandStatus)
: ::DataThingType (),
  CommandStatus_ (CommandStatus, this),
  JointStatuses_ (this),
  PoseStatus_ (this),
  GripperStatus_ (this),
  SettingsStatus_ (this)
{
}

CRCLStatusType::
CRCLStatusType (const CRCLStatusType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  CommandStatus_ (x.CommandStatus_, f, this),
  JointStatuses_ (x.JointStatuses_, f, this),
  PoseStatus_ (x.PoseStatus_, f, this),
  GripperStatus_ (x.GripperStatus_, f, this),
  SettingsStatus_ (x.SettingsStatus_, f, this)
{
}

CRCLStatusType::
CRCLStatusType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  CommandStatus_ (this),
  JointStatuses_ (this),
  PoseStatus_ (this),
  GripperStatus_ (this),
  SettingsStatus_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void CRCLStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // CommandStatus
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "CommandStatus",
          "",
          &::xsd::cxx::tree::factory_impl< CommandStatus_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!CommandStatus_.present ())
        {
          ::std::auto_ptr< CommandStatus_type > r (
            dynamic_cast< CommandStatus_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->CommandStatus_.set (r);
          continue;
        }
      }
    }

    // JointStatuses
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "JointStatuses",
          "",
          &::xsd::cxx::tree::factory_impl< JointStatuses_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->JointStatuses_)
        {
          ::std::auto_ptr< JointStatuses_type > r (
            dynamic_cast< JointStatuses_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->JointStatuses_.set (r);
          continue;
        }
      }
    }

    // PoseStatus
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "PoseStatus",
          "",
          &::xsd::cxx::tree::factory_impl< PoseStatus_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->PoseStatus_)
        {
          ::std::auto_ptr< PoseStatus_type > r (
            dynamic_cast< PoseStatus_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->PoseStatus_.set (r);
          continue;
        }
      }
    }

    // GripperStatus
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "GripperStatus",
          "",
          &::xsd::cxx::tree::factory_impl< GripperStatus_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->GripperStatus_)
        {
          ::std::auto_ptr< GripperStatus_type > r (
            dynamic_cast< GripperStatus_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->GripperStatus_.set (r);
          continue;
        }
      }
    }

    // SettingsStatus
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "SettingsStatus",
          "",
          &::xsd::cxx::tree::factory_impl< SettingsStatus_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->SettingsStatus_)
        {
          ::std::auto_ptr< SettingsStatus_type > r (
            dynamic_cast< SettingsStatus_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->SettingsStatus_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!CommandStatus_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "CommandStatus",
      "");
  }
}

CRCLStatusType* CRCLStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CRCLStatusType (*this, f, c);
}

CRCLStatusType& CRCLStatusType::
operator= (const CRCLStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->CommandStatus_ = x.CommandStatus_;
    this->JointStatuses_ = x.JointStatuses_;
    this->PoseStatus_ = x.PoseStatus_;
    this->GripperStatus_ = x.GripperStatus_;
    this->SettingsStatus_ = x.SettingsStatus_;
  }

  return *this;
}

CRCLStatusType::
~CRCLStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, CRCLStatusType >
_xsd_CRCLStatusType_type_factory_init (
  "CRCLStatusType",
  "");

// GripperStatusType
//

GripperStatusType::
GripperStatusType (const GripperName_type& GripperName)
: ::DataThingType (),
  GripperName_ (GripperName, this),
  HoldingObject_ (this)
{
}

GripperStatusType::
GripperStatusType (::std::auto_ptr< GripperName_type > GripperName)
: ::DataThingType (),
  GripperName_ (GripperName, this),
  HoldingObject_ (this)
{
}

GripperStatusType::
GripperStatusType (const GripperStatusType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  GripperName_ (x.GripperName_, f, this),
  HoldingObject_ (x.HoldingObject_, f, this)
{
}

GripperStatusType::
GripperStatusType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  GripperName_ (this),
  HoldingObject_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void GripperStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // GripperName
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "GripperName",
          "",
          &::xsd::cxx::tree::factory_impl< GripperName_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!GripperName_.present ())
        {
          ::std::auto_ptr< GripperName_type > r (
            dynamic_cast< GripperName_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->GripperName_.set (r);
          continue;
        }
      }
    }

    // HoldingObject
    //
    if (n.name () == "HoldingObject" && n.namespace_ ().empty ())
    {
      if (!this->HoldingObject_)
      {
        this->HoldingObject_.set (HoldingObject_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!GripperName_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "GripperName",
      "");
  }
}

GripperStatusType* GripperStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class GripperStatusType (*this, f, c);
}

GripperStatusType& GripperStatusType::
operator= (const GripperStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->GripperName_ = x.GripperName_;
    this->HoldingObject_ = x.HoldingObject_;
  }

  return *this;
}

GripperStatusType::
~GripperStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, GripperStatusType >
_xsd_GripperStatusType_type_factory_init (
  "GripperStatusType",
  "");

// JointStatusesType
//

JointStatusesType::
JointStatusesType ()
: ::DataThingType (),
  JointStatus_ (this)
{
}

JointStatusesType::
JointStatusesType (const JointStatusesType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  JointStatus_ (x.JointStatus_, f, this)
{
}

JointStatusesType::
JointStatusesType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  JointStatus_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void JointStatusesType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // JointStatus
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "JointStatus",
          "",
          &::xsd::cxx::tree::factory_impl< JointStatus_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< JointStatus_type > r (
          dynamic_cast< JointStatus_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->JointStatus_.push_back (r);
        continue;
      }
    }

    break;
  }
}

JointStatusesType* JointStatusesType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class JointStatusesType (*this, f, c);
}

JointStatusesType& JointStatusesType::
operator= (const JointStatusesType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->JointStatus_ = x.JointStatus_;
  }

  return *this;
}

JointStatusesType::
~JointStatusesType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, JointStatusesType >
_xsd_JointStatusesType_type_factory_init (
  "JointStatusesType",
  "");

// JointStatusType
//

JointStatusType::
JointStatusType (const JointNumber_type& JointNumber)
: ::DataThingType (),
  JointNumber_ (JointNumber, this),
  JointPosition_ (this),
  JointTorqueOrForce_ (this),
  JointVelocity_ (this)
{
}

JointStatusType::
JointStatusType (const JointStatusType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  JointNumber_ (x.JointNumber_, f, this),
  JointPosition_ (x.JointPosition_, f, this),
  JointTorqueOrForce_ (x.JointTorqueOrForce_, f, this),
  JointVelocity_ (x.JointVelocity_, f, this)
{
}

JointStatusType::
JointStatusType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  JointNumber_ (this),
  JointPosition_ (this),
  JointTorqueOrForce_ (this),
  JointVelocity_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void JointStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // JointNumber
    //
    if (n.name () == "JointNumber" && n.namespace_ ().empty ())
    {
      if (!JointNumber_.present ())
      {
        this->JointNumber_.set (JointNumber_traits::create (i, f, this));
        continue;
      }
    }

    // JointPosition
    //
    if (n.name () == "JointPosition" && n.namespace_ ().empty ())
    {
      if (!this->JointPosition_)
      {
        this->JointPosition_.set (JointPosition_traits::create (i, f, this));
        continue;
      }
    }

    // JointTorqueOrForce
    //
    if (n.name () == "JointTorqueOrForce" && n.namespace_ ().empty ())
    {
      if (!this->JointTorqueOrForce_)
      {
        this->JointTorqueOrForce_.set (JointTorqueOrForce_traits::create (i, f, this));
        continue;
      }
    }

    // JointVelocity
    //
    if (n.name () == "JointVelocity" && n.namespace_ ().empty ())
    {
      if (!this->JointVelocity_)
      {
        this->JointVelocity_.set (JointVelocity_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!JointNumber_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "JointNumber",
      "");
  }
}

JointStatusType* JointStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class JointStatusType (*this, f, c);
}

JointStatusType& JointStatusType::
operator= (const JointStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->JointNumber_ = x.JointNumber_;
    this->JointPosition_ = x.JointPosition_;
    this->JointTorqueOrForce_ = x.JointTorqueOrForce_;
    this->JointVelocity_ = x.JointVelocity_;
  }

  return *this;
}

JointStatusType::
~JointStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, JointStatusType >
_xsd_JointStatusType_type_factory_init (
  "JointStatusType",
  "");

// JointLimitType
//

JointLimitType::
JointLimitType (const JointNumber_type& JointNumber)
: ::DataThingType (),
  JointNumber_ (JointNumber, this),
  JointMinPosition_ (this),
  JointMaxPosition_ (this),
  JointMaxTorqueOrForce_ (this),
  JointMaxVelocity_ (this)
{
}

JointLimitType::
JointLimitType (const JointLimitType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  JointNumber_ (x.JointNumber_, f, this),
  JointMinPosition_ (x.JointMinPosition_, f, this),
  JointMaxPosition_ (x.JointMaxPosition_, f, this),
  JointMaxTorqueOrForce_ (x.JointMaxTorqueOrForce_, f, this),
  JointMaxVelocity_ (x.JointMaxVelocity_, f, this)
{
}

JointLimitType::
JointLimitType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  JointNumber_ (this),
  JointMinPosition_ (this),
  JointMaxPosition_ (this),
  JointMaxTorqueOrForce_ (this),
  JointMaxVelocity_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void JointLimitType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // JointNumber
    //
    if (n.name () == "JointNumber" && n.namespace_ ().empty ())
    {
      if (!JointNumber_.present ())
      {
        this->JointNumber_.set (JointNumber_traits::create (i, f, this));
        continue;
      }
    }

    // JointMinPosition
    //
    if (n.name () == "JointMinPosition" && n.namespace_ ().empty ())
    {
      if (!this->JointMinPosition_)
      {
        this->JointMinPosition_.set (JointMinPosition_traits::create (i, f, this));
        continue;
      }
    }

    // JointMaxPosition
    //
    if (n.name () == "JointMaxPosition" && n.namespace_ ().empty ())
    {
      if (!this->JointMaxPosition_)
      {
        this->JointMaxPosition_.set (JointMaxPosition_traits::create (i, f, this));
        continue;
      }
    }

    // JointMaxTorqueOrForce
    //
    if (n.name () == "JointMaxTorqueOrForce" && n.namespace_ ().empty ())
    {
      if (!this->JointMaxTorqueOrForce_)
      {
        this->JointMaxTorqueOrForce_.set (JointMaxTorqueOrForce_traits::create (i, f, this));
        continue;
      }
    }

    // JointMaxVelocity
    //
    if (n.name () == "JointMaxVelocity" && n.namespace_ ().empty ())
    {
      if (!this->JointMaxVelocity_)
      {
        this->JointMaxVelocity_.set (JointMaxVelocity_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!JointNumber_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "JointNumber",
      "");
  }
}

JointLimitType* JointLimitType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class JointLimitType (*this, f, c);
}

JointLimitType& JointLimitType::
operator= (const JointLimitType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->JointNumber_ = x.JointNumber_;
    this->JointMinPosition_ = x.JointMinPosition_;
    this->JointMaxPosition_ = x.JointMaxPosition_;
    this->JointMaxTorqueOrForce_ = x.JointMaxTorqueOrForce_;
    this->JointMaxVelocity_ = x.JointMaxVelocity_;
  }

  return *this;
}

JointLimitType::
~JointLimitType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, JointLimitType >
_xsd_JointLimitType_type_factory_init (
  "JointLimitType",
  "");

// ParallelGripperStatusType
//

ParallelGripperStatusType::
ParallelGripperStatusType (const ::GripperStatusType& _xsd_GripperStatusType_base,
                           const Separation_type& Separation)
: ::GripperStatusType (_xsd_GripperStatusType_base),
  Separation_ (Separation, this)
{
}

ParallelGripperStatusType::
ParallelGripperStatusType (const GripperName_type& GripperName,
                           const Separation_type& Separation)
: ::GripperStatusType (GripperName),
  Separation_ (Separation, this)
{
}

ParallelGripperStatusType::
ParallelGripperStatusType (::std::auto_ptr< GripperName_type > GripperName,
                           const Separation_type& Separation)
: ::GripperStatusType (GripperName),
  Separation_ (Separation, this)
{
}

ParallelGripperStatusType::
ParallelGripperStatusType (const ParallelGripperStatusType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::GripperStatusType (x, f, c),
  Separation_ (x.Separation_, f, this)
{
}

ParallelGripperStatusType::
ParallelGripperStatusType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::GripperStatusType (e, f | ::xml_schema::flags::base, c),
  Separation_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ParallelGripperStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::GripperStatusType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Separation
    //
    if (n.name () == "Separation" && n.namespace_ ().empty ())
    {
      if (!Separation_.present ())
      {
        this->Separation_.set (Separation_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!Separation_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Separation",
      "");
  }
}

ParallelGripperStatusType* ParallelGripperStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ParallelGripperStatusType (*this, f, c);
}

ParallelGripperStatusType& ParallelGripperStatusType::
operator= (const ParallelGripperStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::GripperStatusType& > (*this) = x;
    this->Separation_ = x.Separation_;
  }

  return *this;
}

ParallelGripperStatusType::
~ParallelGripperStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ParallelGripperStatusType >
_xsd_ParallelGripperStatusType_type_factory_init (
  "ParallelGripperStatusType",
  "");

// PoseStatusType
//

PoseStatusType::
PoseStatusType (const Pose_type& Pose)
: ::DataThingType (),
  Pose_ (Pose, this),
  Twist_ (this),
  Wrench_ (this),
  Configuration_ (this)
{
}

PoseStatusType::
PoseStatusType (::std::auto_ptr< Pose_type > Pose)
: ::DataThingType (),
  Pose_ (Pose, this),
  Twist_ (this),
  Wrench_ (this),
  Configuration_ (this)
{
}

PoseStatusType::
PoseStatusType (const PoseStatusType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  Pose_ (x.Pose_, f, this),
  Twist_ (x.Twist_, f, this),
  Wrench_ (x.Wrench_, f, this),
  Configuration_ (x.Configuration_, f, this)
{
}

PoseStatusType::
PoseStatusType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  Pose_ (this),
  Twist_ (this),
  Wrench_ (this),
  Configuration_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void PoseStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Pose
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Pose",
          "",
          &::xsd::cxx::tree::factory_impl< Pose_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!Pose_.present ())
        {
          ::std::auto_ptr< Pose_type > r (
            dynamic_cast< Pose_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Pose_.set (r);
          continue;
        }
      }
    }

    // Twist
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Twist",
          "",
          &::xsd::cxx::tree::factory_impl< Twist_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Twist_)
        {
          ::std::auto_ptr< Twist_type > r (
            dynamic_cast< Twist_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Twist_.set (r);
          continue;
        }
      }
    }

    // Wrench
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Wrench",
          "",
          &::xsd::cxx::tree::factory_impl< Wrench_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Wrench_)
        {
          ::std::auto_ptr< Wrench_type > r (
            dynamic_cast< Wrench_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Wrench_.set (r);
          continue;
        }
      }
    }

    // Configuration
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Configuration",
          "",
          &::xsd::cxx::tree::factory_impl< Configuration_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Configuration_)
        {
          ::std::auto_ptr< Configuration_type > r (
            dynamic_cast< Configuration_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Configuration_.set (r);
          continue;
        }
      }
    }

    break;
  }

  if (!Pose_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Pose",
      "");
  }
}

PoseStatusType* PoseStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class PoseStatusType (*this, f, c);
}

PoseStatusType& PoseStatusType::
operator= (const PoseStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->Pose_ = x.Pose_;
    this->Twist_ = x.Twist_;
    this->Wrench_ = x.Wrench_;
    this->Configuration_ = x.Configuration_;
  }

  return *this;
}

PoseStatusType::
~PoseStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, PoseStatusType >
_xsd_PoseStatusType_type_factory_init (
  "PoseStatusType",
  "");

// SettingsStatusType
//

SettingsStatusType::
SettingsStatusType ()
: ::DataThingType (),
  AngleUnitName_ (this),
  EndEffectorParameterSetting_ (this),
  EndEffectorSetting_ (this),
  ForceUnitName_ (this),
  JointLimits_ (this),
  IntermediatePoseTolerance_ (this),
  LengthUnitName_ (this),
  MaxCartesianLimit_ (this),
  MinCartesianLimit_ (this),
  MotionCoordinated_ (this),
  PoseTolerance_ (this),
  RobotParameterSetting_ (this),
  RotAccelAbsolute_ (this),
  RotAccelRelative_ (this),
  RotSpeedAbsolute_ (this),
  RotSpeedRelative_ (this),
  TorqueUnitName_ (this),
  TransAccelAbsolute_ (this),
  TransAccelRelative_ (this),
  TransSpeedAbsolute_ (this),
  TransSpeedRelative_ (this)
{
}

SettingsStatusType::
SettingsStatusType (const SettingsStatusType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::DataThingType (x, f, c),
  AngleUnitName_ (x.AngleUnitName_, f, this),
  EndEffectorParameterSetting_ (x.EndEffectorParameterSetting_, f, this),
  EndEffectorSetting_ (x.EndEffectorSetting_, f, this),
  ForceUnitName_ (x.ForceUnitName_, f, this),
  JointLimits_ (x.JointLimits_, f, this),
  IntermediatePoseTolerance_ (x.IntermediatePoseTolerance_, f, this),
  LengthUnitName_ (x.LengthUnitName_, f, this),
  MaxCartesianLimit_ (x.MaxCartesianLimit_, f, this),
  MinCartesianLimit_ (x.MinCartesianLimit_, f, this),
  MotionCoordinated_ (x.MotionCoordinated_, f, this),
  PoseTolerance_ (x.PoseTolerance_, f, this),
  RobotParameterSetting_ (x.RobotParameterSetting_, f, this),
  RotAccelAbsolute_ (x.RotAccelAbsolute_, f, this),
  RotAccelRelative_ (x.RotAccelRelative_, f, this),
  RotSpeedAbsolute_ (x.RotSpeedAbsolute_, f, this),
  RotSpeedRelative_ (x.RotSpeedRelative_, f, this),
  TorqueUnitName_ (x.TorqueUnitName_, f, this),
  TransAccelAbsolute_ (x.TransAccelAbsolute_, f, this),
  TransAccelRelative_ (x.TransAccelRelative_, f, this),
  TransSpeedAbsolute_ (x.TransSpeedAbsolute_, f, this),
  TransSpeedRelative_ (x.TransSpeedRelative_, f, this)
{
}

SettingsStatusType::
SettingsStatusType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::DataThingType (e, f | ::xml_schema::flags::base, c),
  AngleUnitName_ (this),
  EndEffectorParameterSetting_ (this),
  EndEffectorSetting_ (this),
  ForceUnitName_ (this),
  JointLimits_ (this),
  IntermediatePoseTolerance_ (this),
  LengthUnitName_ (this),
  MaxCartesianLimit_ (this),
  MinCartesianLimit_ (this),
  MotionCoordinated_ (this),
  PoseTolerance_ (this),
  RobotParameterSetting_ (this),
  RotAccelAbsolute_ (this),
  RotAccelRelative_ (this),
  RotSpeedAbsolute_ (this),
  RotSpeedRelative_ (this),
  TorqueUnitName_ (this),
  TransAccelAbsolute_ (this),
  TransAccelRelative_ (this),
  TransSpeedAbsolute_ (this),
  TransSpeedRelative_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void SettingsStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::DataThingType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // AngleUnitName
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "AngleUnitName",
          "",
          &::xsd::cxx::tree::factory_impl< AngleUnitName_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->AngleUnitName_)
        {
          ::std::auto_ptr< AngleUnitName_type > r (
            dynamic_cast< AngleUnitName_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->AngleUnitName_.set (r);
          continue;
        }
      }
    }

    // EndEffectorParameterSetting
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "EndEffectorParameterSetting",
          "",
          &::xsd::cxx::tree::factory_impl< EndEffectorParameterSetting_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< EndEffectorParameterSetting_type > r (
          dynamic_cast< EndEffectorParameterSetting_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->EndEffectorParameterSetting_.push_back (r);
        continue;
      }
    }

    // EndEffectorSetting
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "EndEffectorSetting",
          "",
          &::xsd::cxx::tree::factory_impl< EndEffectorSetting_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->EndEffectorSetting_)
        {
          ::std::auto_ptr< EndEffectorSetting_type > r (
            dynamic_cast< EndEffectorSetting_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->EndEffectorSetting_.set (r);
          continue;
        }
      }
    }

    // ForceUnitName
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "ForceUnitName",
          "",
          &::xsd::cxx::tree::factory_impl< ForceUnitName_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->ForceUnitName_)
        {
          ::std::auto_ptr< ForceUnitName_type > r (
            dynamic_cast< ForceUnitName_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->ForceUnitName_.set (r);
          continue;
        }
      }
    }

    // JointLimits
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "JointLimits",
          "",
          &::xsd::cxx::tree::factory_impl< JointLimits_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< JointLimits_type > r (
          dynamic_cast< JointLimits_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->JointLimits_.push_back (r);
        continue;
      }
    }

    // IntermediatePoseTolerance
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "IntermediatePoseTolerance",
          "",
          &::xsd::cxx::tree::factory_impl< IntermediatePoseTolerance_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->IntermediatePoseTolerance_)
        {
          ::std::auto_ptr< IntermediatePoseTolerance_type > r (
            dynamic_cast< IntermediatePoseTolerance_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->IntermediatePoseTolerance_.set (r);
          continue;
        }
      }
    }

    // LengthUnitName
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "LengthUnitName",
          "",
          &::xsd::cxx::tree::factory_impl< LengthUnitName_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->LengthUnitName_)
        {
          ::std::auto_ptr< LengthUnitName_type > r (
            dynamic_cast< LengthUnitName_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->LengthUnitName_.set (r);
          continue;
        }
      }
    }

    // MaxCartesianLimit
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "MaxCartesianLimit",
          "",
          &::xsd::cxx::tree::factory_impl< MaxCartesianLimit_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->MaxCartesianLimit_)
        {
          ::std::auto_ptr< MaxCartesianLimit_type > r (
            dynamic_cast< MaxCartesianLimit_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->MaxCartesianLimit_.set (r);
          continue;
        }
      }
    }

    // MinCartesianLimit
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "MinCartesianLimit",
          "",
          &::xsd::cxx::tree::factory_impl< MinCartesianLimit_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->MinCartesianLimit_)
        {
          ::std::auto_ptr< MinCartesianLimit_type > r (
            dynamic_cast< MinCartesianLimit_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->MinCartesianLimit_.set (r);
          continue;
        }
      }
    }

    // MotionCoordinated
    //
    if (n.name () == "MotionCoordinated" && n.namespace_ ().empty ())
    {
      if (!this->MotionCoordinated_)
      {
        this->MotionCoordinated_.set (MotionCoordinated_traits::create (i, f, this));
        continue;
      }
    }

    // PoseTolerance
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "PoseTolerance",
          "",
          &::xsd::cxx::tree::factory_impl< PoseTolerance_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->PoseTolerance_)
        {
          ::std::auto_ptr< PoseTolerance_type > r (
            dynamic_cast< PoseTolerance_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->PoseTolerance_.set (r);
          continue;
        }
      }
    }

    // RobotParameterSetting
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "RobotParameterSetting",
          "",
          &::xsd::cxx::tree::factory_impl< RobotParameterSetting_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        ::std::auto_ptr< RobotParameterSetting_type > r (
          dynamic_cast< RobotParameterSetting_type* > (tmp.get ()));

        if (r.get ())
          tmp.release ();
        else
          throw ::xsd::cxx::tree::not_derived< char > ();

        this->RobotParameterSetting_.push_back (r);
        continue;
      }
    }

    // RotAccelAbsolute
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "RotAccelAbsolute",
          "",
          &::xsd::cxx::tree::factory_impl< RotAccelAbsolute_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->RotAccelAbsolute_)
        {
          ::std::auto_ptr< RotAccelAbsolute_type > r (
            dynamic_cast< RotAccelAbsolute_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->RotAccelAbsolute_.set (r);
          continue;
        }
      }
    }

    // RotAccelRelative
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "RotAccelRelative",
          "",
          &::xsd::cxx::tree::factory_impl< RotAccelRelative_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->RotAccelRelative_)
        {
          ::std::auto_ptr< RotAccelRelative_type > r (
            dynamic_cast< RotAccelRelative_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->RotAccelRelative_.set (r);
          continue;
        }
      }
    }

    // RotSpeedAbsolute
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "RotSpeedAbsolute",
          "",
          &::xsd::cxx::tree::factory_impl< RotSpeedAbsolute_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->RotSpeedAbsolute_)
        {
          ::std::auto_ptr< RotSpeedAbsolute_type > r (
            dynamic_cast< RotSpeedAbsolute_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->RotSpeedAbsolute_.set (r);
          continue;
        }
      }
    }

    // RotSpeedRelative
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "RotSpeedRelative",
          "",
          &::xsd::cxx::tree::factory_impl< RotSpeedRelative_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->RotSpeedRelative_)
        {
          ::std::auto_ptr< RotSpeedRelative_type > r (
            dynamic_cast< RotSpeedRelative_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->RotSpeedRelative_.set (r);
          continue;
        }
      }
    }

    // TorqueUnitName
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "TorqueUnitName",
          "",
          &::xsd::cxx::tree::factory_impl< TorqueUnitName_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->TorqueUnitName_)
        {
          ::std::auto_ptr< TorqueUnitName_type > r (
            dynamic_cast< TorqueUnitName_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->TorqueUnitName_.set (r);
          continue;
        }
      }
    }

    // TransAccelAbsolute
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "TransAccelAbsolute",
          "",
          &::xsd::cxx::tree::factory_impl< TransAccelAbsolute_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->TransAccelAbsolute_)
        {
          ::std::auto_ptr< TransAccelAbsolute_type > r (
            dynamic_cast< TransAccelAbsolute_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->TransAccelAbsolute_.set (r);
          continue;
        }
      }
    }

    // TransAccelRelative
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "TransAccelRelative",
          "",
          &::xsd::cxx::tree::factory_impl< TransAccelRelative_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->TransAccelRelative_)
        {
          ::std::auto_ptr< TransAccelRelative_type > r (
            dynamic_cast< TransAccelRelative_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->TransAccelRelative_.set (r);
          continue;
        }
      }
    }

    // TransSpeedAbsolute
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "TransSpeedAbsolute",
          "",
          &::xsd::cxx::tree::factory_impl< TransSpeedAbsolute_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->TransSpeedAbsolute_)
        {
          ::std::auto_ptr< TransSpeedAbsolute_type > r (
            dynamic_cast< TransSpeedAbsolute_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->TransSpeedAbsolute_.set (r);
          continue;
        }
      }
    }

    // TransSpeedRelative
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "TransSpeedRelative",
          "",
          &::xsd::cxx::tree::factory_impl< TransSpeedRelative_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->TransSpeedRelative_)
        {
          ::std::auto_ptr< TransSpeedRelative_type > r (
            dynamic_cast< TransSpeedRelative_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->TransSpeedRelative_.set (r);
          continue;
        }
      }
    }

    break;
  }
}

SettingsStatusType* SettingsStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SettingsStatusType (*this, f, c);
}

SettingsStatusType& SettingsStatusType::
operator= (const SettingsStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::DataThingType& > (*this) = x;
    this->AngleUnitName_ = x.AngleUnitName_;
    this->EndEffectorParameterSetting_ = x.EndEffectorParameterSetting_;
    this->EndEffectorSetting_ = x.EndEffectorSetting_;
    this->ForceUnitName_ = x.ForceUnitName_;
    this->JointLimits_ = x.JointLimits_;
    this->IntermediatePoseTolerance_ = x.IntermediatePoseTolerance_;
    this->LengthUnitName_ = x.LengthUnitName_;
    this->MaxCartesianLimit_ = x.MaxCartesianLimit_;
    this->MinCartesianLimit_ = x.MinCartesianLimit_;
    this->MotionCoordinated_ = x.MotionCoordinated_;
    this->PoseTolerance_ = x.PoseTolerance_;
    this->RobotParameterSetting_ = x.RobotParameterSetting_;
    this->RotAccelAbsolute_ = x.RotAccelAbsolute_;
    this->RotAccelRelative_ = x.RotAccelRelative_;
    this->RotSpeedAbsolute_ = x.RotSpeedAbsolute_;
    this->RotSpeedRelative_ = x.RotSpeedRelative_;
    this->TorqueUnitName_ = x.TorqueUnitName_;
    this->TransAccelAbsolute_ = x.TransAccelAbsolute_;
    this->TransAccelRelative_ = x.TransAccelRelative_;
    this->TransSpeedAbsolute_ = x.TransSpeedAbsolute_;
    this->TransSpeedRelative_ = x.TransSpeedRelative_;
  }

  return *this;
}

SettingsStatusType::
~SettingsStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, SettingsStatusType >
_xsd_SettingsStatusType_type_factory_init (
  "SettingsStatusType",
  "");

// ThreeFingerGripperStatusType
//

ThreeFingerGripperStatusType::
ThreeFingerGripperStatusType (const ::GripperStatusType& _xsd_GripperStatusType_base)
: ::GripperStatusType (_xsd_GripperStatusType_base),
  Finger1Position_ (this),
  Finger2Position_ (this),
  Finger3Position_ (this),
  Finger1Force_ (this),
  Finger2Force_ (this),
  Finger3Force_ (this)
{
}

ThreeFingerGripperStatusType::
ThreeFingerGripperStatusType (const GripperName_type& GripperName)
: ::GripperStatusType (GripperName),
  Finger1Position_ (this),
  Finger2Position_ (this),
  Finger3Position_ (this),
  Finger1Force_ (this),
  Finger2Force_ (this),
  Finger3Force_ (this)
{
}

ThreeFingerGripperStatusType::
ThreeFingerGripperStatusType (::std::auto_ptr< GripperName_type > GripperName)
: ::GripperStatusType (GripperName),
  Finger1Position_ (this),
  Finger2Position_ (this),
  Finger3Position_ (this),
  Finger1Force_ (this),
  Finger2Force_ (this),
  Finger3Force_ (this)
{
}

ThreeFingerGripperStatusType::
ThreeFingerGripperStatusType (const ThreeFingerGripperStatusType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::GripperStatusType (x, f, c),
  Finger1Position_ (x.Finger1Position_, f, this),
  Finger2Position_ (x.Finger2Position_, f, this),
  Finger3Position_ (x.Finger3Position_, f, this),
  Finger1Force_ (x.Finger1Force_, f, this),
  Finger2Force_ (x.Finger2Force_, f, this),
  Finger3Force_ (x.Finger3Force_, f, this)
{
}

ThreeFingerGripperStatusType::
ThreeFingerGripperStatusType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::GripperStatusType (e, f | ::xml_schema::flags::base, c),
  Finger1Position_ (this),
  Finger2Position_ (this),
  Finger3Position_ (this),
  Finger1Force_ (this),
  Finger2Force_ (this),
  Finger3Force_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void ThreeFingerGripperStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::GripperStatusType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Finger1Position
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Finger1Position",
          "",
          &::xsd::cxx::tree::factory_impl< Finger1Position_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Finger1Position_)
        {
          ::std::auto_ptr< Finger1Position_type > r (
            dynamic_cast< Finger1Position_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Finger1Position_.set (r);
          continue;
        }
      }
    }

    // Finger2Position
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Finger2Position",
          "",
          &::xsd::cxx::tree::factory_impl< Finger2Position_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Finger2Position_)
        {
          ::std::auto_ptr< Finger2Position_type > r (
            dynamic_cast< Finger2Position_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Finger2Position_.set (r);
          continue;
        }
      }
    }

    // Finger3Position
    //
    {
      ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
        ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
          "Finger3Position",
          "",
          &::xsd::cxx::tree::factory_impl< Finger3Position_type >,
          false, true, i, n, f, this));

      if (tmp.get () != 0)
      {
        if (!this->Finger3Position_)
        {
          ::std::auto_ptr< Finger3Position_type > r (
            dynamic_cast< Finger3Position_type* > (tmp.get ()));

          if (r.get ())
            tmp.release ();
          else
            throw ::xsd::cxx::tree::not_derived< char > ();

          this->Finger3Position_.set (r);
          continue;
        }
      }
    }

    // Finger1Force
    //
    if (n.name () == "Finger1Force" && n.namespace_ ().empty ())
    {
      if (!this->Finger1Force_)
      {
        this->Finger1Force_.set (Finger1Force_traits::create (i, f, this));
        continue;
      }
    }

    // Finger2Force
    //
    if (n.name () == "Finger2Force" && n.namespace_ ().empty ())
    {
      if (!this->Finger2Force_)
      {
        this->Finger2Force_.set (Finger2Force_traits::create (i, f, this));
        continue;
      }
    }

    // Finger3Force
    //
    if (n.name () == "Finger3Force" && n.namespace_ ().empty ())
    {
      if (!this->Finger3Force_)
      {
        this->Finger3Force_.set (Finger3Force_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }
}

ThreeFingerGripperStatusType* ThreeFingerGripperStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ThreeFingerGripperStatusType (*this, f, c);
}

ThreeFingerGripperStatusType& ThreeFingerGripperStatusType::
operator= (const ThreeFingerGripperStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::GripperStatusType& > (*this) = x;
    this->Finger1Position_ = x.Finger1Position_;
    this->Finger2Position_ = x.Finger2Position_;
    this->Finger3Position_ = x.Finger3Position_;
    this->Finger1Force_ = x.Finger1Force_;
    this->Finger2Force_ = x.Finger2Force_;
    this->Finger3Force_ = x.Finger3Force_;
  }

  return *this;
}

ThreeFingerGripperStatusType::
~ThreeFingerGripperStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, ThreeFingerGripperStatusType >
_xsd_ThreeFingerGripperStatusType_type_factory_init (
  "ThreeFingerGripperStatusType",
  "");

// VacuumGripperStatusType
//

VacuumGripperStatusType::
VacuumGripperStatusType (const ::GripperStatusType& _xsd_GripperStatusType_base,
                         const IsPowered_type& IsPowered)
: ::GripperStatusType (_xsd_GripperStatusType_base),
  IsPowered_ (IsPowered, this)
{
}

VacuumGripperStatusType::
VacuumGripperStatusType (const GripperName_type& GripperName,
                         const IsPowered_type& IsPowered)
: ::GripperStatusType (GripperName),
  IsPowered_ (IsPowered, this)
{
}

VacuumGripperStatusType::
VacuumGripperStatusType (::std::auto_ptr< GripperName_type > GripperName,
                         const IsPowered_type& IsPowered)
: ::GripperStatusType (GripperName),
  IsPowered_ (IsPowered, this)
{
}

VacuumGripperStatusType::
VacuumGripperStatusType (const VacuumGripperStatusType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::GripperStatusType (x, f, c),
  IsPowered_ (x.IsPowered_, f, this)
{
}

VacuumGripperStatusType::
VacuumGripperStatusType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::GripperStatusType (e, f | ::xml_schema::flags::base, c),
  IsPowered_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void VacuumGripperStatusType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::GripperStatusType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // IsPowered
    //
    if (n.name () == "IsPowered" && n.namespace_ ().empty ())
    {
      if (!IsPowered_.present ())
      {
        this->IsPowered_.set (IsPowered_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!IsPowered_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "IsPowered",
      "");
  }
}

VacuumGripperStatusType* VacuumGripperStatusType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class VacuumGripperStatusType (*this, f, c);
}

VacuumGripperStatusType& VacuumGripperStatusType::
operator= (const VacuumGripperStatusType& x)
{
  if (this != &x)
  {
    static_cast< ::GripperStatusType& > (*this) = x;
    this->IsPowered_ = x.IsPowered_;
  }

  return *this;
}

VacuumGripperStatusType::
~VacuumGripperStatusType ()
{
}

static
const ::xsd::cxx::tree::type_factory_initializer< 0, char, VacuumGripperStatusType >
_xsd_VacuumGripperStatusType_type_factory_init (
  "VacuumGripperStatusType",
  "");

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::CRCLStatusType > (
    ::CRCLStatus (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::CRCLStatusType > (
    ::CRCLStatus (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::CRCLStatusType > (
    ::CRCLStatus (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::CRCLStatus (isrc, f, p);
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::CRCLStatus (isrc, h, f, p);
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::CRCLStatus (isrc, h, f, p);
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::CRCLStatus (isrc, f, p);
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::CRCLStatus (isrc, h, f, p);
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::CRCLStatus (isrc, h, f, p);
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::CRCLStatusType > (
    ::CRCLStatus (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::CRCLStatusType > (
    ::CRCLStatus (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::CRCLStatusType > (
    ::CRCLStatus (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::CRCLStatusType > (
      ::CRCLStatus (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
      "CRCLStatus",
      "",
      &::xsd::cxx::tree::factory_impl< ::CRCLStatusType >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {
    ::std::auto_ptr< ::CRCLStatusType > r (
      dynamic_cast< ::CRCLStatusType* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "CRCLStatus",
    "");
}

::std::auto_ptr< ::CRCLStatusType >
CRCLStatus (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
    ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
      "CRCLStatus",
      "",
      &::xsd::cxx::tree::factory_impl< ::CRCLStatusType >,
      true, true, e, n, f, 0));

  if (tmp.get () != 0)
  {

    ::std::auto_ptr< ::CRCLStatusType > r (
      dynamic_cast< ::CRCLStatusType* > (tmp.get ()));

    if (r.get ())
      tmp.release ();
    else
      throw ::xsd::cxx::tree::not_derived< char > ();

    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "CRCLStatus",
    "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

void
CRCLStatus (::std::ostream& o,
            const ::CRCLStatusType& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::CRCLStatus (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
CRCLStatus (::std::ostream& o,
            const ::CRCLStatusType& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::CRCLStatus (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
CRCLStatus (::std::ostream& o,
            const ::CRCLStatusType& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::CRCLStatus (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
CRCLStatus (::xercesc::XMLFormatTarget& t,
            const ::CRCLStatusType& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::CRCLStatus (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
CRCLStatus (::xercesc::XMLFormatTarget& t,
            const ::CRCLStatusType& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::CRCLStatus (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
CRCLStatus (::xercesc::XMLFormatTarget& t,
            const ::CRCLStatusType& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::CRCLStatus (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
CRCLStatus (::xercesc::DOMDocument& d,
            const ::CRCLStatusType& s,
            ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (typeid (::CRCLStatusType) == typeid (s))
  {
    if (n.name () == "CRCLStatus" &&
        n.namespace_ () == "")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CRCLStatus",
        "");
    }
  }
  else
  {
    ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
      "CRCLStatus",
      "",
      e, n, s);
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
CRCLStatus (const ::CRCLStatusType& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d;

  if (typeid (::CRCLStatusType) == typeid (s))
  {
    d = ::xsd::cxx::xml::dom::serialize< char > (
      "CRCLStatus",
      "",
      m, f);
  }
  else
  {
    d = ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ().serialize (
      "CRCLStatus",
      "",
      m, s, f);
  }

  ::CRCLStatus (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const CommandStateEnumType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const CommandStateEnumType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const CommandStateEnumType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CommandStateEnumType >
_xsd_CommandStateEnumType_type_serializer_init (
  "CommandStateEnumType",
  "");


void
operator<< (::xercesc::DOMElement& e, const CommandStatusType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // CommandID
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "CommandID",
        e));

    s << i.CommandID ();
  }

  // StatusID
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "StatusID",
        e));

    s << i.StatusID ();
  }

  // CommandState
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const CommandStatusType::CommandState_type& x (i.CommandState ());
    if (typeid (CommandStatusType::CommandState_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "CommandState",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "CommandState",
        "",
        false, true, e, x);
  }

  // StateDescription
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.StateDescription ())
    {
      const CommandStatusType::StateDescription_type& x (*i.StateDescription ());
      if (typeid (CommandStatusType::StateDescription_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "StateDescription",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "StateDescription",
          "",
          false, true, e, x);
    }
  }

  // ProgramFile
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.ProgramFile ())
    {
      const CommandStatusType::ProgramFile_type& x (*i.ProgramFile ());
      if (typeid (CommandStatusType::ProgramFile_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ProgramFile",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ProgramFile",
          "",
          false, true, e, x);
    }
  }

  // ProgramIndex
  //
  if (i.ProgramIndex ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ProgramIndex",
        e));

    s << *i.ProgramIndex ();
  }

  // ProgramLength
  //
  if (i.ProgramLength ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ProgramLength",
        e));

    s << *i.ProgramLength ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CommandStatusType >
_xsd_CommandStatusType_type_serializer_init (
  "CommandStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const CRCLStatusType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // CommandStatus
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const CRCLStatusType::CommandStatus_type& x (i.CommandStatus ());
    if (typeid (CRCLStatusType::CommandStatus_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "CommandStatus",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "CommandStatus",
        "",
        false, true, e, x);
  }

  // JointStatuses
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.JointStatuses ())
    {
      const CRCLStatusType::JointStatuses_type& x (*i.JointStatuses ());
      if (typeid (CRCLStatusType::JointStatuses_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "JointStatuses",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "JointStatuses",
          "",
          false, true, e, x);
    }
  }

  // PoseStatus
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.PoseStatus ())
    {
      const CRCLStatusType::PoseStatus_type& x (*i.PoseStatus ());
      if (typeid (CRCLStatusType::PoseStatus_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PoseStatus",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "PoseStatus",
          "",
          false, true, e, x);
    }
  }

  // GripperStatus
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.GripperStatus ())
    {
      const CRCLStatusType::GripperStatus_type& x (*i.GripperStatus ());
      if (typeid (CRCLStatusType::GripperStatus_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "GripperStatus",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "GripperStatus",
          "",
          false, true, e, x);
    }
  }

  // SettingsStatus
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.SettingsStatus ())
    {
      const CRCLStatusType::SettingsStatus_type& x (*i.SettingsStatus ());
      if (typeid (CRCLStatusType::SettingsStatus_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "SettingsStatus",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "SettingsStatus",
          "",
          false, true, e, x);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, CRCLStatusType >
_xsd_CRCLStatusType_type_serializer_init (
  "CRCLStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const GripperStatusType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // GripperName
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const GripperStatusType::GripperName_type& x (i.GripperName ());
    if (typeid (GripperStatusType::GripperName_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "GripperName",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "GripperName",
        "",
        false, true, e, x);
  }

  // HoldingObject
  //
  if (i.HoldingObject ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "HoldingObject",
        e));

    s << *i.HoldingObject ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, GripperStatusType >
_xsd_GripperStatusType_type_serializer_init (
  "GripperStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const JointStatusesType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // JointStatus
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (JointStatusesType::JointStatus_const_iterator
         b (i.JointStatus ().begin ()), n (i.JointStatus ().end ());
         b != n; ++b)
    {
      if (typeid (JointStatusesType::JointStatus_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "JointStatus",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "JointStatus",
          "",
          false, true, e, *b);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, JointStatusesType >
_xsd_JointStatusesType_type_serializer_init (
  "JointStatusesType",
  "");


void
operator<< (::xercesc::DOMElement& e, const JointStatusType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // JointNumber
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointNumber",
        e));

    s << i.JointNumber ();
  }

  // JointPosition
  //
  if (i.JointPosition ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointPosition",
        e));

    s << ::xml_schema::as_double(*i.JointPosition ());
  }

  // JointTorqueOrForce
  //
  if (i.JointTorqueOrForce ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointTorqueOrForce",
        e));

    s << ::xml_schema::as_double(*i.JointTorqueOrForce ());
  }

  // JointVelocity
  //
  if (i.JointVelocity ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointVelocity",
        e));

    s << ::xml_schema::as_double(*i.JointVelocity ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, JointStatusType >
_xsd_JointStatusType_type_serializer_init (
  "JointStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const JointLimitType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // JointNumber
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointNumber",
        e));

    s << i.JointNumber ();
  }

  // JointMinPosition
  //
  if (i.JointMinPosition ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointMinPosition",
        e));

    s << ::xml_schema::as_double(*i.JointMinPosition ());
  }

  // JointMaxPosition
  //
  if (i.JointMaxPosition ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointMaxPosition",
        e));

    s << ::xml_schema::as_double(*i.JointMaxPosition ());
  }

  // JointMaxTorqueOrForce
  //
  if (i.JointMaxTorqueOrForce ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointMaxTorqueOrForce",
        e));

    s << ::xml_schema::as_double(*i.JointMaxTorqueOrForce ());
  }

  // JointMaxVelocity
  //
  if (i.JointMaxVelocity ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "JointMaxVelocity",
        e));

    s << ::xml_schema::as_double(*i.JointMaxVelocity ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, JointLimitType >
_xsd_JointLimitType_type_serializer_init (
  "JointLimitType",
  "");


void
operator<< (::xercesc::DOMElement& e, const ParallelGripperStatusType& i)
{
  e << static_cast< const ::GripperStatusType& > (i);

  // Separation
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Separation",
        e));

    s << ::xml_schema::as_double(i.Separation ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ParallelGripperStatusType >
_xsd_ParallelGripperStatusType_type_serializer_init (
  "ParallelGripperStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const PoseStatusType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // Pose
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    const PoseStatusType::Pose_type& x (i.Pose ());
    if (typeid (PoseStatusType::Pose_type) == typeid (x))
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Pose",
          e));

      s << x;
    }
    else
      tsm.serialize (
        "Pose",
        "",
        false, true, e, x);
  }

  // Twist
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Twist ())
    {
      const PoseStatusType::Twist_type& x (*i.Twist ());
      if (typeid (PoseStatusType::Twist_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Twist",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Twist",
          "",
          false, true, e, x);
    }
  }

  // Wrench
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Wrench ())
    {
      const PoseStatusType::Wrench_type& x (*i.Wrench ());
      if (typeid (PoseStatusType::Wrench_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Wrench",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Wrench",
          "",
          false, true, e, x);
    }
  }

  // Configuration
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Configuration ())
    {
      const PoseStatusType::Configuration_type& x (*i.Configuration ());
      if (typeid (PoseStatusType::Configuration_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Configuration",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Configuration",
          "",
          false, true, e, x);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, PoseStatusType >
_xsd_PoseStatusType_type_serializer_init (
  "PoseStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const SettingsStatusType& i)
{
  e << static_cast< const ::DataThingType& > (i);

  // AngleUnitName
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.AngleUnitName ())
    {
      const SettingsStatusType::AngleUnitName_type& x (*i.AngleUnitName ());
      if (typeid (SettingsStatusType::AngleUnitName_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "AngleUnitName",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "AngleUnitName",
          "",
          false, true, e, x);
    }
  }

  // EndEffectorParameterSetting
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (SettingsStatusType::EndEffectorParameterSetting_const_iterator
         b (i.EndEffectorParameterSetting ().begin ()), n (i.EndEffectorParameterSetting ().end ());
         b != n; ++b)
    {
      if (typeid (SettingsStatusType::EndEffectorParameterSetting_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EndEffectorParameterSetting",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "EndEffectorParameterSetting",
          "",
          false, true, e, *b);
    }
  }

  // EndEffectorSetting
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.EndEffectorSetting ())
    {
      const SettingsStatusType::EndEffectorSetting_type& x (*i.EndEffectorSetting ());
      if (typeid (SettingsStatusType::EndEffectorSetting_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "EndEffectorSetting",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "EndEffectorSetting",
          "",
          false, true, e, x);
    }
  }

  // ForceUnitName
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.ForceUnitName ())
    {
      const SettingsStatusType::ForceUnitName_type& x (*i.ForceUnitName ());
      if (typeid (SettingsStatusType::ForceUnitName_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "ForceUnitName",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "ForceUnitName",
          "",
          false, true, e, x);
    }
  }

  // JointLimits
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (SettingsStatusType::JointLimits_const_iterator
         b (i.JointLimits ().begin ()), n (i.JointLimits ().end ());
         b != n; ++b)
    {
      if (typeid (SettingsStatusType::JointLimits_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "JointLimits",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "JointLimits",
          "",
          false, true, e, *b);
    }
  }

  // IntermediatePoseTolerance
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.IntermediatePoseTolerance ())
    {
      const SettingsStatusType::IntermediatePoseTolerance_type& x (*i.IntermediatePoseTolerance ());
      if (typeid (SettingsStatusType::IntermediatePoseTolerance_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "IntermediatePoseTolerance",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "IntermediatePoseTolerance",
          "",
          false, true, e, x);
    }
  }

  // LengthUnitName
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.LengthUnitName ())
    {
      const SettingsStatusType::LengthUnitName_type& x (*i.LengthUnitName ());
      if (typeid (SettingsStatusType::LengthUnitName_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "LengthUnitName",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "LengthUnitName",
          "",
          false, true, e, x);
    }
  }

  // MaxCartesianLimit
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.MaxCartesianLimit ())
    {
      const SettingsStatusType::MaxCartesianLimit_type& x (*i.MaxCartesianLimit ());
      if (typeid (SettingsStatusType::MaxCartesianLimit_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MaxCartesianLimit",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "MaxCartesianLimit",
          "",
          false, true, e, x);
    }
  }

  // MinCartesianLimit
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.MinCartesianLimit ())
    {
      const SettingsStatusType::MinCartesianLimit_type& x (*i.MinCartesianLimit ());
      if (typeid (SettingsStatusType::MinCartesianLimit_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "MinCartesianLimit",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "MinCartesianLimit",
          "",
          false, true, e, x);
    }
  }

  // MotionCoordinated
  //
  if (i.MotionCoordinated ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "MotionCoordinated",
        e));

    s << *i.MotionCoordinated ();
  }

  // PoseTolerance
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.PoseTolerance ())
    {
      const SettingsStatusType::PoseTolerance_type& x (*i.PoseTolerance ());
      if (typeid (SettingsStatusType::PoseTolerance_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "PoseTolerance",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "PoseTolerance",
          "",
          false, true, e, x);
    }
  }

  // RobotParameterSetting
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    for (SettingsStatusType::RobotParameterSetting_const_iterator
         b (i.RobotParameterSetting ().begin ()), n (i.RobotParameterSetting ().end ());
         b != n; ++b)
    {
      if (typeid (SettingsStatusType::RobotParameterSetting_type) == typeid (*b))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RobotParameterSetting",
            e));

        s << *b;
      }
      else
        tsm.serialize (
          "RobotParameterSetting",
          "",
          false, true, e, *b);
    }
  }

  // RotAccelAbsolute
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.RotAccelAbsolute ())
    {
      const SettingsStatusType::RotAccelAbsolute_type& x (*i.RotAccelAbsolute ());
      if (typeid (SettingsStatusType::RotAccelAbsolute_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RotAccelAbsolute",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "RotAccelAbsolute",
          "",
          false, true, e, x);
    }
  }

  // RotAccelRelative
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.RotAccelRelative ())
    {
      const SettingsStatusType::RotAccelRelative_type& x (*i.RotAccelRelative ());
      if (typeid (SettingsStatusType::RotAccelRelative_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RotAccelRelative",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "RotAccelRelative",
          "",
          false, true, e, x);
    }
  }

  // RotSpeedAbsolute
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.RotSpeedAbsolute ())
    {
      const SettingsStatusType::RotSpeedAbsolute_type& x (*i.RotSpeedAbsolute ());
      if (typeid (SettingsStatusType::RotSpeedAbsolute_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RotSpeedAbsolute",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "RotSpeedAbsolute",
          "",
          false, true, e, x);
    }
  }

  // RotSpeedRelative
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.RotSpeedRelative ())
    {
      const SettingsStatusType::RotSpeedRelative_type& x (*i.RotSpeedRelative ());
      if (typeid (SettingsStatusType::RotSpeedRelative_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "RotSpeedRelative",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "RotSpeedRelative",
          "",
          false, true, e, x);
    }
  }

  // TorqueUnitName
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.TorqueUnitName ())
    {
      const SettingsStatusType::TorqueUnitName_type& x (*i.TorqueUnitName ());
      if (typeid (SettingsStatusType::TorqueUnitName_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TorqueUnitName",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "TorqueUnitName",
          "",
          false, true, e, x);
    }
  }

  // TransAccelAbsolute
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.TransAccelAbsolute ())
    {
      const SettingsStatusType::TransAccelAbsolute_type& x (*i.TransAccelAbsolute ());
      if (typeid (SettingsStatusType::TransAccelAbsolute_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TransAccelAbsolute",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "TransAccelAbsolute",
          "",
          false, true, e, x);
    }
  }

  // TransAccelRelative
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.TransAccelRelative ())
    {
      const SettingsStatusType::TransAccelRelative_type& x (*i.TransAccelRelative ());
      if (typeid (SettingsStatusType::TransAccelRelative_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TransAccelRelative",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "TransAccelRelative",
          "",
          false, true, e, x);
    }
  }

  // TransSpeedAbsolute
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.TransSpeedAbsolute ())
    {
      const SettingsStatusType::TransSpeedAbsolute_type& x (*i.TransSpeedAbsolute ());
      if (typeid (SettingsStatusType::TransSpeedAbsolute_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TransSpeedAbsolute",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "TransSpeedAbsolute",
          "",
          false, true, e, x);
    }
  }

  // TransSpeedRelative
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.TransSpeedRelative ())
    {
      const SettingsStatusType::TransSpeedRelative_type& x (*i.TransSpeedRelative ());
      if (typeid (SettingsStatusType::TransSpeedRelative_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "TransSpeedRelative",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "TransSpeedRelative",
          "",
          false, true, e, x);
    }
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, SettingsStatusType >
_xsd_SettingsStatusType_type_serializer_init (
  "SettingsStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const ThreeFingerGripperStatusType& i)
{
  e << static_cast< const ::GripperStatusType& > (i);

  // Finger1Position
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Finger1Position ())
    {
      const ThreeFingerGripperStatusType::Finger1Position_type& x (*i.Finger1Position ());
      if (typeid (ThreeFingerGripperStatusType::Finger1Position_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Finger1Position",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Finger1Position",
          "",
          false, true, e, x);
    }
  }

  // Finger2Position
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Finger2Position ())
    {
      const ThreeFingerGripperStatusType::Finger2Position_type& x (*i.Finger2Position ());
      if (typeid (ThreeFingerGripperStatusType::Finger2Position_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Finger2Position",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Finger2Position",
          "",
          false, true, e, x);
    }
  }

  // Finger3Position
  //
  {
    ::xsd::cxx::tree::type_serializer_map< char >& tsm (
      ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

    if (i.Finger3Position ())
    {
      const ThreeFingerGripperStatusType::Finger3Position_type& x (*i.Finger3Position ());
      if (typeid (ThreeFingerGripperStatusType::Finger3Position_type) == typeid (x))
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            "Finger3Position",
            e));

        s << x;
      }
      else
        tsm.serialize (
          "Finger3Position",
          "",
          false, true, e, x);
    }
  }

  // Finger1Force
  //
  if (i.Finger1Force ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Finger1Force",
        e));

    s << ::xml_schema::as_double(*i.Finger1Force ());
  }

  // Finger2Force
  //
  if (i.Finger2Force ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Finger2Force",
        e));

    s << ::xml_schema::as_double(*i.Finger2Force ());
  }

  // Finger3Force
  //
  if (i.Finger3Force ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Finger3Force",
        e));

    s << ::xml_schema::as_double(*i.Finger3Force ());
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ThreeFingerGripperStatusType >
_xsd_ThreeFingerGripperStatusType_type_serializer_init (
  "ThreeFingerGripperStatusType",
  "");


void
operator<< (::xercesc::DOMElement& e, const VacuumGripperStatusType& i)
{
  e << static_cast< const ::GripperStatusType& > (i);

  // IsPowered
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "IsPowered",
        e));

    s << i.IsPowered ();
  }
}

static
const ::xsd::cxx::tree::type_serializer_initializer< 0, char, VacuumGripperStatusType >
_xsd_VacuumGripperStatusType_type_serializer_init (
  "VacuumGripperStatusType",
  "");


#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

